{
  "name": "CoinToss",
  "functions": [
    {
      "name": "compute_note_hash_and_nullifier",
      "functionType": "unconstrained",
      "isInternal": false,
      "parameters": [
        {
          "name": "contract_address",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "nonce",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "storage_slot",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "preimage",
          "type": {
            "kind": "array",
            "length": 4,
            "type": {
              "kind": "field"
            }
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [
        {
          "kind": "array",
          "length": 4,
          "type": {
            "kind": "field"
          }
        }
      ],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "constructor",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [
        {
          "name": "divinity",
          "type": {
            "kind": "struct",
            "path": "aztec::types::address::AztecAddress",
            "fields": [
              {
                "name": "address",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "private"
        },
        {
          "name": "private_oracle",
          "type": {
            "kind": "struct",
            "path": "aztec::types::address::AztecAddress",
            "fields": [
              {
                "name": "address",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "private"
        },
        {
          "name": "token",
          "type": {
            "kind": "struct",
            "path": "aztec::types::address::AztecAddress",
            "fields": [
              {
                "name": "address",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "private"
        },
        {
          "name": "bet_amount",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [],
      "bytecode": "H4sIAAAAAAAA/+XdZ3MTVxQG4JWtgpNAICRxo9j0YmBXWlmrkOJAeiGkF1KwYikhBRPiFEIKIZXee++99/rTGM47cwWLEPBBxwyXd2fOrOtqn7vS1nvPuew4zl7n+hQx8zYzdyubvJgsI1ZmuSm31ffzmWTeS3ntbjKbC9Kun861Bl7gpYN0RzJIpfKBH2SyuWzGzXp+Ku8V0tlUwSw4preObne447KMeDe44/e4OyHLSHSDO6HsvtX7vdL1bFRcz4hpyyazvFqJKxJ1Zl5v5g1m3nifz1sk+plthnbpbdql3z2wXv2dGyft99UAR+8zWmy/4joOMA7sWwaG2jdqfn+n9x2mptD/VZUstyn0d80S1SZuNbUpOqPO7beLW9nk1Tr6+yXtdayzYB3rLVjHBufuHIPcyiav2dE9BhWnQRJ9zdc1zs2fYfwsWmLCPiWm7Ksxy8VUFXodR/d1/HLnb26FU01onavLtGW0TFvGQj+LlXjxfc/Q752Sdull/jauvA1K961toe+Lr9VDoo/5enpn17TCrIkz8+1d+Y5JnV358BsrXtIgYUCkTOMU4UV0omQ54UZOhObh17y21hqtEV6m9qd5kGPHme9gnfUs+En/hvWsUm7PiKJ5SDdtG21zlaJ5qCXmakXzMEvMUUXzcEvMMUXzCEvMcUXzSEvMCUXzKEvM/RXNoy0xNyqaWwjNYwjNYwnN4wjNLqHZIzQnCc0pQrNPaE4TmlsJzRlCc0BozhKanyA0jyc0P0loforQ/DSh+RlCcxuh+VlC8wRC80RC83OE5ucJzS8Qml8kNL9EaH6Z0PwKoflVQvNrhObXCc2TCM1vEJonE5rfJDS/RWh+m9D8DqH5XULze4Tm9wnNHxCaPyQ0f0RonkJo/pjQ/Amh+VNC82eE5qmE5nZCc47Q/DmhuYPQnCc0FwjNXxCavyQ0TyM0f0Vo/prQ/A2h+VtC83RCc6cl5mZF8wzC7fwdoXkmofl7QnMXofkHQvOPhOafCM0/E5pnEZp/ITTPJjT/Smj+jdD8O6H5D0vMAxXNcwi385+E5rmE5r8IzX8Tmv8hNP9LaP6P0Pw/oXkeoXk+oXkBoXkhoXkRoXkxoXmJJebBiualhNt5GaF5OaF5BaF5JaF5FaF5NaF5DaF5LaF5HaF5PaF5A6F5I6F5E6F5M6F5C6F5K6F5G6F5O6F5B6F5J6F5F6F5N6F5D6F5L6F5H6F5P6H5AKH5IKH5EKH5MKH5iCXmHormo5aYaxTNxywxP6BoPm6J+UFF8wlLzA8pmk9aYu6paD5libmXovm0JeaHFc1nLDH3VjSftcTcR9F8zhLzI4rm85aY+yqaL1hiflTRfNES82OK5kuWmB9XNF9WNDeY5USMuVoiKhGTiEskJHBNiGskXDPgHBrnlDjHwjkHjsE4JmEfjX0WPsN4T2Mbw1wrUSdRL9EQat8NZj5EYqjEMInhEiMkRkqMkhgt0SIxRmKsxDh4JTyJJNpRwpdIS7RKZCQCiawEat6Pl0BNdNQIR83sYg1p1BieIIEatKjJihqlqNmJGpao6Ygah6j5hxp4qAmHGmmoGYYaWpMlUGMJNYdQgwc1aVCjBTVLUMMDNS1Q4wE1D6ZIICc+csQjZzpyiE+VQI7pnARyECMnL3LUImcrcpgipydyXCLnI3IgIicgcuQhZxxyqM2QQI4t5JxCDibkJEKOHuSsQQ4X5DRBjg/kvJgtgZwIyBGAMfMYQz5HAmOM50pgDCrGZGKMIsbsYQwbxnRhjBPG/GAMDMaEYIwExgygD/1SCfSxRp9j9MFFn1T00USfRfThQ5829PFab7Yx+sSgjwj6TKAPwVYJPGPeLoFnkHgmh2dUeGaDZxi4p4973Ljni3uguCeIe2S4Z4R7KLingGtsXHPiGgzXJDhHxzkrzuFwToNjPI55OAZgn4h9BD4zxekqP+Y04UalAAA=",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "get_config_unconstrained",
      "functionType": "unconstrained",
      "isInternal": false,
      "parameters": [],
      "returnTypes": [
        {
          "kind": "struct",
          "path": "types::config_note::ConfigNote",
          "fields": [
            {
              "name": "divinity",
              "type": {
                "kind": "struct",
                "path": "aztec::types::address::AztecAddress",
                "fields": [
                  {
                    "name": "address",
                    "type": {
                      "kind": "field"
                    }
                  }
                ]
              }
            },
            {
              "name": "private_oracle",
              "type": {
                "kind": "struct",
                "path": "aztec::types::address::AztecAddress",
                "fields": [
                  {
                    "name": "address",
                    "type": {
                      "kind": "field"
                    }
                  }
                ]
              }
            },
            {
              "name": "token",
              "type": {
                "kind": "struct",
                "path": "aztec::types::address::AztecAddress",
                "fields": [
                  {
                    "name": "address",
                    "type": {
                      "kind": "field"
                    }
                  }
                ]
              }
            },
            {
              "name": "bet_amount",
              "type": {
                "kind": "field"
              }
            },
            {
              "name": "header",
              "type": {
                "kind": "struct",
                "path": "aztec::note::note_header::NoteHeader",
                "fields": [
                  {
                    "name": "contract_address",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "storage_slot",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "is_transient",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ]
              }
            }
          ]
        }
      ],
      "bytecode": "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z2eTffVb8lXGMf83TFgl8+IV6FyD9kKwuX7txWBz7dulYHPd3EvB5pq7y8Hmer0rwT4H7WqwL0DTteA5aBqXvwBNz0hehKbn1ZegheTf4ORav8vQtF7rCjSNwcWp79Rrrqse/tfubkvLlOtY69jn+2RF+O3N+O3N+L3dd7GKYCllWEoNWPoNsfQYYuk1xFIxxNJhiKVsiGWhIZZuQyxVQyydhljaDLH0GWJZYIilyxBLuyGWlnvMcrv3gxTeDW0gw59og8FeAE3PQ3ugaW6qF5rWCSyE1prDp2vTADS1+UFoKtfF0HSNHYKmvkv+k/Mme+bC9Qy1FedoPovvo2htQRu0CcQpje9qS5sMdic0PS/tgrYCtv5rHQHLRmkZhaY0j0FT3oxDUx5OQFNeL4OmMpmEpnVty6FpXS/Z9V7Dypx0sA3onHr4X7u7LW0D9FPHvnzxPZ2VBljaDbF0GWJZYIilzxBLmyGWTkMsVUMs3YZYFhpiKRti6TDEUjHE0muIpccQS78hltZ5YtH4UfEuzrAU5Xcg43dgnvwOZ/wOz5PfkYzfkXny6+U7P369fOfHr+XynYzqd9slPi/Q1ugZ0CRYlkdlmf09nGVx40x/W3oicpxJHOPIE+Wf2KsI5/dFxyPnVwt8Kl7tjxfnN03/2AekfyyHY2we008+Z3VWZ3XWO2WdcNZCWL2+OquzOqtfC5zV66uzOquz+rXAWb2+OquzOqtfC5zV66uzOquz+rXAWb2+OquzOqtfC5zV66uzOquz+rXAWb2+OquzOqtfC5zV66uzOquz+rXAWb2+OquzOqtfC+6cNfE7GtXvlZlKxm+yNXqnfLTAPEjiXBU3zvT959XgV1rlp4pw1sXVkdPWAp+KV/vkc1ZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZnvV9YqwhvBcuqAlhKGZZSTr5oW2KIZZEhlmFD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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "get_user_bets_unconstrained",
      "functionType": "unconstrained",
      "isInternal": false,
      "parameters": [
        {
          "name": "start_offset",
          "type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [
        {
          "kind": "array",
          "length": 10,
          "type": {
            "kind": "struct",
            "path": "std::option::Option",
            "fields": [
              {
                "name": "_is_some",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "_value",
                "type": {
                  "kind": "struct",
                  "path": "types::bet_note::BetNote",
                  "fields": [
                    {
                      "name": "owner",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::types::address::AztecAddress",
                        "fields": [
                          {
                            "name": "address",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "bet_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "bet",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "escrow_randomness",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "header",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::note::note_header::NoteHeader",
                        "fields": [
                          {
                            "name": "contract_address",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "nonce",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "storage_slot",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "is_transient",
                            "type": {
                              "kind": "boolean"
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          }
        }
      ],
      "bytecode": "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YZU6IKzC6odVrgV+WKW++mGVOiCswuqHVa4FflilvvphlTogrMLqh1WuBX5Ypb76YZU6IKzC6odVrgV+WKW++mGVOiCswuqHVa4FflilvvphlTogrMLqh1WuBX5Ypb76YZU6IKzC6of1UrctZbfZqd39fUnDrtpyvVPe7DEPVJwj3cYZvv88CvgprWQnBeFYF0c5TlscbFK8tI98wiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqswiqslwtrCsLzgGWkB5aYwRKz5AttIxixVDNiaWDEUsSIJZ8RSy0jlhpGLFWMWJKMWAoZsSQYsdQzYqljxNLIiKWJEUslI5ZiRiwFjFjil5glCQwx0Cg8DzQaIydAG639+aCN0f4C0MZCOknr1v4i0MZpfzFo48FPvxO0fwRoE7W/HrRJ2l8H2mTtrwUto/01oPVofzVovdrfANoU7W8ErU/7m0Cbqv2VoE3T/irQpmt/J2gztL8DtJna3w7aLO1vAY3KEMucynAUaFSGo0GjMhwDGpXhWNCoDLtBozIcBxqVIZZpifZPAI3ayETQSrV/Emhl2j8ZtHLtz4BWof09oFE59IJG5TAFNCr/PtConkwFjerTNNCo3k0HjernDNCoHs8EjeoYlakqi6LaoXA6H9so2cE2Ostib6aFi/zYJ9E5Wf2bubAt7JPQThb2yVYJMExnwFLAiKWYEUslI5YmRiyNjFjqGLHUM2JJMGIpZMSSZMRSxYilhhFLLSOWfEYsRYxYGhixVDNiGcGIJc9gwTH1LNBoPI9j8zwjPpxT0fFFOn0px+nDOVMM0olbFvxkX7GUumXJpIClFOyUu7XTi3O980lzObBUuWXpw/nk+bDgff5Ktyw9Ks5qt3GG0+Ya4Ke0kp0UhGOZ1zhOWxxsUry0j3zCemWzKpYygxPv25Qx4COt0h9Lb9JgUVuufgmfhda7ZenD+2Hn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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    }
  ],
  "events": [],
  "debug": {
    "debugSymbols": [
      "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59UZ59UZ59UZ59UZ59UZ59UZ59UZ59UZ59UZ59UZ59UZ59UZ59UZ59UZ59UZ59UZ59UZ59UZ59UZ59UZ5zUY5zUY5zUY5zUY5zVuSmMH47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47wG47w2xnltjPPaGOe1Mc5ruymN3RjntTHOa2Oc18Y4r41xXhvjvDbGeW2M89oY57UxzmtjnNfGOK+NcV4b47w2xnltjPPaGOe1Mc5rY5zXxjivjXFeG+O8NsZ5bYzz2hjntTHOa2Oc18Y4r41xXhvjvDbGeW2M89oY57UxzmtjnNfGOK+NcV4b47w2xnltjPPaGOe1Mc5rY5zXxjivjXFeG+O8NsZ5bYzz2hjntTHOa2Oc18Y4r41xXhvjvDbGeW2M89pOOq99/1jSb3FuybnGrlxyrrErl5xr7Mol5xq7csm5xq5ccq6xK5eca+zKJecau3DJSee1cgnT2JPOa+USprEnndfKJUxjTzqvlUuYxp50XiuXMI096bxWLmEae9J5rVzCNPak81q5hGnsSee1cgnT2JPOa+USprEnndfKJUxjTzqvlUuYxp50XiuXMI096bxWLmEae9J5rVyiNHY/6bxWLlEau590XiuXKI3db0pj95POa+USpbH7See1conS2P2k81q45KTzWrmEaexJ57VyCdPYk85r5RKmsSed18olTGNPOq+VS5jGnnReK5cwjT3pvFYuYRp70nmtXMI09qTzWrmEaexJ57VyCdPYk85r5RKmsSed18olTGNPOq+VS5jGnnReK5cwjT3pvFYuYRp70nmtXMI09qTzWrmEaexJ57VyCdPYk85r5RKmsSed18olTGNPOq+VS5jG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2Xm5zM7LZXZeLrPzcpmdl8vsvFxm5+UyOy+X2Xm5zM7LZXZeLrPzcpmdl8vsvFxm5+UyOy+X2Xm5zM7LZXZeLrPzcpmdl8vsvFxm5+UyOy+X2Xm5zM7LZXZeLrPzcpmdl8vsvFxm5+UyOy+X2Xm5zM7LZXZeLrPzcpmdl8vsvFxm5+UyOy+X2Xm5zM7LZXZeLrPzcpmdl8vsvFxm5+UyOy+X2Xm5zM7LZXZeLrPzcpmdl8vsvFxm5+UyOy+X2Xm5zM7LZXZeLrPzcpmdl8vsvFxm5+UyOy+X2Xm5zM7LZXZeLrPzcpmdl8vsvFxm5+UyOy+X2XmFzM4rZHZeIbPzCpmdV3yonLEhs/MKmZ1XyOy8QmbnFTI7r5DZeYXMzitkdl4hs/MKmZ1XyOy8QmbnFTI7r5DZeYXMzitkdl4hs/MKmZ1XyOy8QmbnFTI7r5DZeYXMzitkdl4hs/MKmZ1XyOy8QmbnFTI7r5DZeYXMzitkdl4hs/MKmZ1XyOy8QmbnFTI7r5DZeYXMzitkdl4hs/MKmZ1XyOy8QmbnFTI7r5DZeYXMzitkdl4hs/MKmZ1XyOy8QmbnFTI7r5DZeYXMzitkdl4hs/MKmZ1XyOy8QmbnFTI7r5DZeYXMzitkdl4hs/MKmZ1XyOy8QmbnFTI7r5DZeYXMzitkdl4hs/MKmZ1XyOy8QmbnFTI7r5DZeYXMzitkdl4hs/MKmZ1XyOy8QmbnFTI7r5DZeYXMzitkdl4hs/MKmZ1XyOy8QmbnFTI7r5DZeYXMzmvI7LyGzM5ryOy8hszOa3yonLFDZuc1ZHZeQ2bnNWR2XkNm5zVkdl5DZuc1ZHZeQ2bnNWR2XkNm5zVkdl5DZuc1ZHZeQ2bnNWR2XkNm5zVkdl5DZuc1ZHZeQ2bnNWR2XkNm5zVkdl5DZuc1ZHZeQ2bnNWR2XkNm5zVkdl5DZuc1ZHZeQ2bnNWR2XkNm5zVkdl5DZuc1ZHZeQ2bnNWR2XkNm5zVkdl5DZuc1ZHZeQ2bnNWR2XkNm5zVkdl5DZuc1ZHZeQ2bnNWR2XkNm5zVkdl5DZuc1ZHZeQ2bnNWR2XkNm5zVkdl5DZuc1ZHZeQ2bnNWR2XkNm5zVkdl5DZuc1ZHZeQ2bnNWR2XkNm5zVkdl5DZuc1ZHZeQ2bnNWR2XkNm5zVkdl5DZuc1ZHZeQ2bnNWR2XkNm5zVkdl5DZuc1ZHZeQ2bnNWR2XkNm5zVkdl5DZuc1ZHZeQ2bnNWR2XkNm5zVldl5TZuc1ZXZeU2bnNT9Uztgps/OaMjuvKbPzmjI7rymz85oyO68ps/OaMjuvKbPzmjI7rymz85oyO68ps/OaMjuvKbPzmjI7rymz85oyO68ps/OaMjuvKbPzmjI7rymz85oyO68ps/OaMjuvKbPzmjI7rymz85oyO68ps/OaMjuvKbPzmjI7rymz85oyO68ps/OaMjuvKbPzmjI7rymz85oyO68ps/OaMjuvKbPzmjI7rymz85oyO68ps/OaMjuvKbPzmjI7rymz85oyO68ps/OaMjuvKbPzmjI7rymz85oyO68ps/OaMjuvKbPzmjI7rymz85oyO68ps/OaMjuvKbPzmjI7rymz85oyO68ps/OaMjuvKbPzmjI7rymz85oyO68ps/OaMjuvKbPzmjI7rymz85oyO68ps/OaMjuvKbPzmjI7rymz85oyO68ps/OaMjuvKbPzmjI7rymz81oyO68ls/NaMjuvJbPzWh8qZ+yS2XktmZ3Xktl5LZmd15LZeS2ZndeS2XktmZ3Xktl5LZmd15LZeS2ZndeS2XktmZ3Xktl5LZmd15LZeS2ZndeS2XktmZ3Xktl5LZmd15LZeS2ZndeS2XktmZ3Xktl5LZmd15LZeS2ZndeS2XktmZ3Xktl5LZmd15LZeS2ZndeS2XktmZ3Xktl5LZmd15LZeS2ZndeS2XktmZ3Xktl5LZmd15LZeS2ZndeS2XktmZ3Xktl5LZmd15LZeS2ZndeS2XktmZ3Xktl5LZmd15LZeS2ZndeS2XktmZ3Xktl5LZmd15LZeS2ZndeS2XktmZ3Xktl5LZmd15LZeS2ZndeS2XktmZ3Xktl5LZmd15LZeS2ZndeS2XktmZ3Xktl5LZmd15LZeS2ZndeS2XktmZ3Xktl5LZmd15LZeS2ZndeS2XktmZ3Xktl5LZmd15LZeW2ZndeW2XltmZ3Xltl57Q+VM3bL7Ly2zM5ry+y8tszOa8vsvLbMzmvL7Ly2zM5ry+y8tszOa8vsvLbMzmvL7Ly2zM5ry+y8tszOa8vsvLbMzmvL7Ly2zM5ry+y8tszOa8vsvLbMzmvL7Ly2zM5ry+y8tszOa8vsvLbMzmvL7Ly2zM5ry+y8tszOa8vsvLbMzmvL7Ly2zM5ry+y8tszOa8vsvLbM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IS9qyIsa8qKGvKghL2rIixryooa8qCEvasiLGvKihryoIS9qyIsa8qKGvKghL2rIixryooa8qCEvasiLGvKihryoIS9qyIsa8qKGvKghL2rIixryooa8qCEvasiLGvKihryoIS9qyIsa8qKGvKghL2rIixryooa8qCEvasiLGvKihryoIS9qyIsa8qKGvKghL2rIixryooa8qCEvasiLGvKihryoIS9qyIsa8qKGvKghb2rImxrypoa8qSFvasibGvKmhrypIW9qyJsa8qaGvKkhb2rImxrypoa8qSFvasibGvKmhrypIW9qyJsa8qaGvKkhb2rImxrypoa8qSFvasibGvKmhrypIW9qyJsa8qaGvKkhb2rImxrypoa8qSFvasibGvKmhrypIW9qyJsa8qaGvKkhb2rImxrypoa8qSFvasibGvKmhrypIW9qyJsa8qaGvKkhb2rImxrypoa8qSFvasibGvKmhrypIW9qyJsa8qaGvKkhb2rImxrypoa8qSFvasibGvKmhrypIW9qyJsa8qaGvKkhb2rImxrypoa8qSFvasibGvKmhrypIW9qyJsa8qaGvKkhb2rImxrypoa8qSFf1JAvasgXNeSLGvJFDfmihnxRQ76oIV/UkC9qyBc15Isa8kUN+aKGfFFDvqghX9SQL2rIFzXkixryRQ35ooZ8UUO+qCFf1JAvasgXNeSLGvJFDfmihnxRQ76oIV/UkC9qyBc15Isa8kUN+aKGfFFDvqghX9SQL2rIFzXkixryRQ35ooZ8UUO+qCFf1JAvasgXNeSLGvJFDfmihnxRQ76oIV/UkC9qyBc15Isa8kUN+aKGfFFDvqghX9SQL2rIFzXkixryRQ35ooZ8UUO+qCFf1JAvasgXNeSLGvJFDfmihnxRQ76oIV/UkC9qyBc15Isa8kUN+aKGfFFDvqghX9SQL2rIFzXkixryRQ35ooZ8UUO+qCFf1JAvasgXNeSLGnJSQ05qyEkNOakhJzXkpIac1JCTGnJSQ05qyEkNOakhJzXkpIac1JCTGnJSQ05qyEkNOakhJzXkpIac1JCTGnJSQ05qyEkNOakhJzXkpIac1JCTGnJSQ05qyEkNOakhJzXkpIac1JCTGnJSQ05qyEkNOakhJzXkpIac1JCTGnJSQ05qyEkNOakhJzXkpIac1JCTGnJSQ05qyEkNOakhJzXk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/YGJm/7AxF3DrPvH57zFx293QvHxFSyb0wmWzWkEa5jtBMvmdIJlczrBsjmdYNmcTrBsTidYNqcTpM2pYbYThM25apjtBGFzrhpmO0HYnKuG2U4QNueqYbYThM25apjtBGlzapjtBGlzapjtBGlzapjtBGlzapjtBGlzapjtBGlzapjtBGlzapjtBGlzapjtBGlzapjtBGlzapjtBGlzapjtBGlzapjtBGlzapjtBGlzapjtBGlzapjtBGlzapjtBGlzapjtBGlzapjtBGlzapjtBGlzapjtBGlzapjtBGlzapjtBGlzapjtBGlzapjtBGlzapjtBGlzapjtBGlzapjtBGlz6lfQO0HanFp0O0HanPqV7k6QNqc25E6QNqc25E6QNqc25E6QNqc25E6QNqc25E6QNqc25E6QNqc25E6QNqc25E6QNqc25E6QNoca8kUN+aKGfFFDvqghX9SQL2rIFzXkixryRQ35ooZ8UUNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQ82DIw6+vYOwyWDenEayb0wjWzfltcIwqeDDkRrBuztjxFby8DNbNaQTr5jSCdXNmfv0zLp9lsG5OI1j/PjaC9e/jU3B81L4asT9LHnF9lMHyq9oJll/VTrD8qnaC5f3YCB4IccXXCbBGcVvdwbpyjWBdud8GZ5bB+uhI//xOL37/lbYM1pVrBOvK5cd4CB5ArxGsj477hP/8fbxbWQbr38dGsC75x4iv4OGj1iVvBOuSf8T6NVgWoAa9TrBszu+Cq+xqDXqdYNmccP/129SN4kAeHzXodYJlczrB+ni0XL8Gf9+c6ltYPR40Nf+9f5m6la9fpu7w65epG//6Zer74/XL1HfT65ep7723L1MD6vuXqe/r1y/zPadATbnvX+Z7ToGaid+/zPecAjVBv3+Z7zkF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Mjsvl9l5uczOy2V2Xi6z83KZnZfL7LxcZuflMjsvl9l5uczOy2V2Xi6z83KZnZfL7LxcZuflMjsvl9l5uczOy2V2Xi6z83KZnZfL7LxcZuflMjsvl9l5uczOy2V2Xi6z83KZnZfL7LxcZuflMjsvl9l5uczOy2V2Xi6z83KZnZfL7LxcZuflMjsvl9l5uczOy2V2Xi6z83KZnZfL7LxcZuflMjsvl9l5uczOy2V2Xi6z83KZnZfL7LxcZuflMjsvl9l5uczOy2V2Xi6z83KZnZfL7LxcZuflMjsvl9l5uczOy2V2Xi6z83KZnZfL7LxcZuflMjsvl9l5uczOy2V2XiGz8wqZnVfI7LxCZucVHypnbMjsvEJm5xUyO6+Q2XmFzM4rZHZeIbPzCpmdV8jsvEJm5xUyO6+Q2XmFzM4rZHZeIbPzCpmdV8jsvEJm5xUyO6+Q2XmFzM4rZHZeIbPzCpmdV8jsvEJm5xUyO6+Q2XmFzM4rZHZeIbPzCpmdV8jsvEJm5xUyO6+Q2XmFzM4rZHZeIbPzCpmdV8jsvEJm5xUyO6+Q2XmFzM4rZHZeIbPzCpmdV8jsvEJm5xUyO6+Q2XmFzM4rZHZeIbPzCpmdV8jsvEJm5xUyO6+Q2XmFzM4rZHZeIbPzCpmdV8jsvEJm5xUyO6+Q2XmFzM4rZHZeIbPzCpmdV8jsvEJm5xUyO6+Q2XmFzM4rZHZeIbPzCpmdV8jsvEJm5xUyO6+Q2XmFzM4rZHZeIbPzCpmdV8jsvEJm5xUyO6+Q2XmFzM4rZHZeIbPzSpmdV8rsvFJm55UyO6/8UDljU2bnlTI7r5TZeaXMzitldl4ps/NKmZ1Xyuy8UmbnlTI7r5TZeaXMzitldl4ps/NKmZ1Xyuy8UmbnlTI7r5TZeaXMzitldl4ps/NKmZ1Xyuy8UmbnlTI7r5TZeaXMzitldl4ps/NKmZ1Xyuy8UmbnlTI7r5TZeaXMzitldl4ps/NKmZ1Xyuy8UmbnlTI7r5TZeaXMzitldl4ps/NKmZ1Xyuy8UmbnlTI7r5TZeaXMzitldl4ps/NKmZ1Xyuy8UmbnlTI7r5TZeaXMzitldl4ps/NKmZ1Xyuy8UmbnlTI7r5TZeaXMzitldl4ps/NKmZ1Xyuy8UmbnlTI7r5TZeaXMzitldl4ps/NKmZ1Xyuy8UmbnlTI7r5TZeaXMzitldl4ps/NKmZ1Xyuy8UmbnlTI7r5TZeaXMzitldl4ps/NKmZ1Xk9l5NZmdV5PZeTWZnVf7UDljm8zOq8nsvJrMzqvJ7LyazM6ryey8mszOq8nsvJrMzqvJ7LyazM6ryey8mszOq8nsvJrMzqvJ7LyazM6ryey8mszOq8nsvJrMzqvJ7LyazM6ryey8mszOq8nsvJrMzqvJ7LyazM6ryey8mszOq8nsvJrMzqvJ7LyazM6ryey8mszOq8nsvJrMzqvJ7LyazM6ryey8mszOq8nsvJrMzqvJ7LyazM6ryey8mszOq8nsvJrMzqvJ7LyazM6ryey8mszOq8nsvJrMzqvJ7LyazM6ryey8mszOq8nsvJrMzqvJ7LyazM6ryey8mszOq8nsvJrMzqvJ7LyazM6ryey8mszOq8nsvJrMzqvJ7LyazM6ryey8mszOq8nsvJrMzqvJ7LyazM6ryey8mszOq8nsvJrMzqvJ7LyazM6ryey8mszOq8nsvJrMzqvJ7LyazM6rZHZeJbPzKpmdV8nsvOpD5YwtmZ1Xyey8SmbnVTI7r5LZeZXMzqtkdl4ls/MqmZ1Xyey8SmbnVTI7r5LZeZXMzqtkdl4ls/MqmZ1Xyey8SmbnVTI7r5LZeZXMzqtkdl4ls/MqmZ1Xyey8SmbnVTI7r5LZeZXMzqtkdl4ls/MqmZ1Xyey8SmbnVTI7r5LZeZXMzqtkdl4ls/MqmZ1Xyey8SmbnVTI7r5LZeZXMzqtkdl4ls/MqmZ1Xyey8SmbnVTI7r5LZeZXMzqtkdl4ls/MqmZ1Xyey8SmbnVTI7r5LZeZXMzqtkdl4ls/MqmZ1Xyey8SmbnVTI7r5LZeZXMzqtkdl4ls/MqmZ1Xyey8SmbnVTI7r5LZeZXMzqtkdl4ls/MqmZ1Xyey8SmbnVTI7r5LZeZXMzqtkdl4ls/MqmZ1Xyey8SmbnVTI7r5LZeZXMzqtkdl5dZufVZXZeXWbn1WV2Xv1D5YztMjuvLrPz6jI7ry6z8+oyO68us/PqMjuvLrPz6jI7ry6z8+oyO68us/PqMjuvLrPz6jI7ry6z8+oyO68us/PqMjuvLrPz6jI7ry6z8+oyO68us/PqMjuvLrPz6jI7ry6z8+oyO68us/PqMjuvLrPz6jI7ry6z8+oyO68us/PqMjuvLrPz6jI7ry6z8+oyO68us/PqMjuvLrPz6jI7ry6z8+oyO68us/Pq39x5jfF1J+3Dv3cn3ztj37yT752xb97J987YN+/ke2fsm3fyvTP2zTv53hn74p18c+f15p1874x9806+d8a+eScyZ+w3d15v3onMGfvNndebdyJzxn5z5/Xmncicsd/ceb15JzJn7Dd3Xm/eicwZ+82d15t3InPGfnPn9eadyJyx39x5vXknMmfsN3deb96JzBn7zZ3Xm3cic8Z+c+f15p3InLHf3Hm9eScyZ+w3d15v3onMGfvNndebdyJzxn5z5/Xmncicsd/ceb15JzJn7Dd3Xm/eicwZ+82d15t3onLGjm/uvN68E5Uzdnxz5/XmnaicseND5Ywd39x5vXknKmfs+ObO6807UTljxzd3Xi/eyTd3Xm/eicwZ+82d15t3InPGfnPn9eadyJyx39x5vXknMmfsN3deb96JzBn7zZ3Xm3cic8Z+c+f15p3InLHf3Hm9eScyZ+w3d15v3onMGfvNndebdyJzxn5z5/Xmncicsd/ceb15JzJn7Dd3Xm/eicwZ+82d15t3InPGfnPn9eadyJyx39x5vXknMmfsN3deb96JzBn7zZ3Xm3cic8Z+c+f15p3InLHf3Hm9eScyZ+w3d15v3onMGfvNndebdyJzxsrsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryuy8pszOa8rsvKbMzmt+qJyxU2bnNWV2XlNm5zVldl5TZuc1ZXZeU2bnNWV2XlNm5zVldl5TZuc1ZXZeU2bnNWV2XlNm5zVldl5TZuc1ZXZeU2bnNWV2XlNm5zVldl5TZuc1ZXZeU2bnNWV2XlNm5zVldl5TZuc1ZXZeU2bnNWV2XlNm5zVldl5TZuc1ZXZeU2bnNWV2XlNm5zVldl5TZuc1ZXZeU2bnNWV2XlNm5zVldl5TZuc1ZXZeU2bnNWV2XlNm5zVldl5TZuc1ZXZeU2bnNWV2XlNm5zVldl5TZuc1ZXZeU2bnNWV2XlNm5zVldl5TZuc1ZXZeU2bnNWV2XlNm5zVldl5TZuc1ZXZeU2bnNWV2XlNm5zVldl5TZuc1ZXZeU2bnNWV2XlNm5zVldl5TZuc1ZXZeU2bnNWV2XlNm5zVldl5TZuc1ZXZeU2bnNWV2XlNm5zVldl5TZudlHzJDr3UrKqfsuhWVY3bdiso5u25F5aBdt6Jy0q5bUTlq162onLXrVlQO23UrOqetzORr3YrOaSsz+lq3onPaysy+1q3onLYyw691Kzqnrcz0a92KzmkrM/5at6Jz2srMv9at6Jy2MgOwdSs6p63MBGzdis5pKzMCW7eic9rKzMDWreictjJDsHUrOqetzBRs3YrOaSszBlu3onPayszB1q3onLYyg7B1KzqnrcwkbN2KzmkrMwpbt6Jz2srMwtat6Jy2MsOwdSs6p63MNGzdis5pKzMOW7eic9rKzMPWreictjIDsXUrOqetzERs3YrOaSszElu3onPayszE1q3onLYyQ7F1KzqnrcxUbN2KzmkrMxZbt6Jz2srMxdat6Jy2MoOxdSs6p63MZGzdis5pKzMaW7eic9rKzMbWreictjLDsXUrOqetzHRs3YrOaSszHlu3onPayszH1q3onLYyA7J1KzqnrcyEbN2KzmkrMyJbt6Jz2srMyNat6Jy2MkOydSs6p63MlGzdisxpazpbMtPZkpnOlsx0tmT2IXPams6WzHS2ZKazJTOdLZnpbMlMZ0tmOlsy09mSmc6WzHS2ZKazJTOdLZnpbMlMZ0tmOlsy09mSmc6WzHS2ZKazJTOdLZnpbMlMZ0tmOlsy09mSmc6WzHS2ZKazJTOdLZnpbMlMZ0tmOlsy09mSmc6WzHS2ZKazJTOdLZnpbMlMZ0tmOlsy09mSmc6WzHS2ZKazJTOdLZnpbMlMZ0tmOlsy09mSmc6WzHS2ZKazJTOdLZnpbMlMZ0tmOlsy09mSmc6WzHS2ZKazJTOdLZnpbMlMZ0tmOlsy09mSmc6WzHS2ZKazJTOdLZnpbMlMZ0tmOlsy09mSmc6WzHS2ZKazJTOdLZnpbMlMZ0tmOlsy09mSmc6WzHS2ZKazJTOdLZnpbMlMZ0tmOlsy09mSmc6WzHS2ZKazJTOdLZnpbMlMZ0tmOlsy19mSuc6WzHW2ZK6zJfMPmdPWdbZkrrMlc50tmetsyVxnS+Y6WzLX2ZK5zpbMdbZkrrMlc50tmetsyVxnS+Y6WzLX2ZK5zpbMdbZkrrMlc50tmetsyVxnS+Y6WzLX2ZK5zpbMdbZkrrMlc50tmetsyVxnS+Y6WzLX2ZK5zpbMdbZkrrMlc50tmetsyVxnS+Y6WzLX2ZK5zpbMdbZkrrMlc50tmetsyVxnS+Y6WzLX2ZK5zpbMdbZkrrMlc50tmetsyVxnS+Y6WzLX2ZK5zpbMdbZkrrMlc50tmetsyVxnS+Y6WzLX2ZK5zpbMdbZkrrMlc50tmetsyVxnS+Y6WzLX2ZK5zpbMdbZkrrMlc50tmetsyVxnS+Y6WzLX2ZK5zpbMdbZkrrMlc50tmetsyVxnS+Y6WzLX2ZK5zpbMdbZkrrMlc50tmetsyVxnS+Y6WzLX2ZKFzpYsdLZkobMlC50tWXzInLahsyULnS1Z6GzJQmdLFjpbstDZkoXOlix0tmShsyULnS1Z6GzJQmdLFjpbstDZkoXOlix0tmShsyULnS1Z6GzJQmdLFjpbstDZkoXOlix0tmShsyULnS1Z6GzJQmdLFjpbstDZkoXOlix0tmShsyULnS1Z6GzJQmdLFjpbstDZkoXOlix0tmShsyULnS1Z6GzJQmdLFjpbstDZkoXOlix0tmShsyULnS1Z6GzJQmdLFjpbstDZkoXOlix0tmShsyULnS1Z6GzJQmdLFjpbstDZkoXOlix0tmShsyULnS1Z6GzJQmdLFjpbstDZkoXOlix0tmShsyULnS1Z6GzJQmdLFjpbstDZkoXOlix0tmShsyULnS1Z6GzJQmdLFjpbstDZkoXOlix0tmShsyULnS1Z6GzJQmdLFjpbstDZkoXOlix1tmSpsyVLnS1Z6mzJ8kPmtE2dLVnqbMlSZ0uWOluy1NmSpc6WLHW2ZKmzJUudLVnqbMlSZ0uWOluy1NmSpc6WLHW2ZKmzJUudLVnqbMlSZ0uWOluy1NmSpc6WLHW2ZKmzJUudLVnqbMlSZ0uWOluy1NmSpc6WLHW2ZKmzJUudLVnqbMlSZ0uWOluy1NmSpc6WLHW2ZKmzJUudLVnqbMlSZ0uWOluy1NmSpc6WLHW2ZKmzJUudLVnqbMlSZ0uWOluy1NmSpc6WLHW2ZKmzJUudLVnqbMlSZ0uWOluy1NmSpc6WLHW2ZKmzJUudLVnqbMlSZ0uWOluy1NmSpc6WLHW2ZKmzJUudLVnqbMlSZ0uWOluy1NmSpc6WLHW2ZKmzJUudLVnqbMlSZ0uWOluy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gxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOasiNGnKjhtyoITdqyI0acqOG3KghN2rIjRpyo4bcqCE3asiNGnKjhtyoITdqyI0acqOG3KghN2rIjRpyo4bcqCE3asiNGnKjhtyoITdqyI0acqOG3KghN2rIjRpyo4bcqCE3asiNGnKjhtyoITdqyI0acqOG3KghN2rIjRpyo4bcqCE3asiNGnKjhtyoITdqyI0acqOG3KghN2rIjRpyo4bcqCE3asiNGnKjhtyoITdqyI0acqOG3KghN2rIjRpyo4bcqCE3asiNGnKjhtyoITdqyI0acqOG3KghN2rIjRpyo4bcqCE3asiNGnKjhtyoITdqyI0acqOG3KghN2rIjRpyo4bcqCE3asiNGnKjhtyoITdqyEUNuaghFzXkooZc1JCLGnJRQy5qyEUNuaghFzXkooZc1JCLGnJRQy5qyEUNuaghFzXkooZc1JCLGnJRQy5qyEUNuaghFzXkooZc1JCLGnJRQy5qyEUNuaghFzXkooZc1JCLGnJRQy5qyEUNuaghFzXkooZc1JCLGnJRQy5qyEUNuaghFzXkooZc1JCLGnJRQy5qyEUNuaghFzXkooZc1JCLGnJRQy5qyEUNuaghFzXkooZc1JCLGnJRQy5qyEUNuaghFzXkooZc1JCLGnJRQy5qyEUNuaghFzXkooZc1JCLGnJRQy5qyEUNuaghFzXkooZc1JCLGnJRQy5qyEUNuaghFzXk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"
    ],
    "fileMap": {
      "1": {
        "source": "mod types;\n\n/// @notice This contract implements a private coin toss game between users.\n/// @dev The contract is deployed with a bet_amount and a private oracle.\n///      The user can create a bet note with a bet (true or false) which is later settled by the private oracle.\n///      The users that betted for the winner receive (in equal parts) the bets made by the users that lost.\ncontract CoinToss {\n\n    /////////////////////////////////////////////////////////////////////\n    //                             Imports                             //\n    /////////////////////////////////////////////////////////////////////\n\n    use crate::types::oracle::{\n        DivinityAddressSubmitQuestionStruct, \n        FromSubmitQuestionStruct, \n        PrivateOraclePrivateContextInterface, \n    };\n\n    use crate::types::{\n        bet_note::{BetNote, BetNoteMethods, BET_NOTE_LEN},\n        config_note::{ConfigNote, ConfigNoteMethods, CONFIG_NOTE_LEN},\n        token::{\n            AccountsBroadcastEscrowNoteForStruct,\n            FromEscrowStruct,\n            FromTransferStruct, \n            OwnerEscrowStruct,\n            OwnerSettleEscrowStruct,\n            RecipientSettleEscrowStruct,\n            TokenPrivateContextInterface, \n            ToTransferStruct\n        }\n    };\n\n    use dep::aztec::{\n        context::Context,\n        log::emit_encrypted_log,\n        note::{\n            note_getter_options::NoteGetterOptions,\n            note_header::NoteHeader,\n            note_viewer_options::NoteViewerOptions,\n            utils as note_utils\n        },\n        oracle::{\n            get_public_key::get_public_key,\n            rand::rand\n        },\n        selector::compute_selector,\n        state_vars::{\n            immutable_singleton::ImmutableSingleton,\n            set::Set\n        },\n        types::address::AztecAddress\n    };\n\n    use dep::std::option::Option;\n\n    /////////////////////////////////////////////////////////////////////\n    //                             Storage                             //\n    /////////////////////////////////////////////////////////////////////\n\n    global CONFIG_NOTE_SLOT = 1;\n    global BETS_SLOT = 2;\n\n    /// @member config The config note, containing the divinity address, the private oracle address, the token address and the bet amount\n    /// @member bets The set of bet notes (ie active bets)\n    struct Storage {\n        config: ImmutableSingleton<ConfigNote, CONFIG_NOTE_LEN>,\n        bets: Set<BetNote, BET_NOTE_LEN>,\n    }\n\n    impl Storage {\n        fn init(context: Context) -> Self {\n            Storage {\n                config: ImmutableSingleton::new(\n                    context,\n                    CONFIG_NOTE_SLOT,\n                    ConfigNoteMethods,\n                ),\n                bets: Set::new(context, BETS_SLOT, BetNoteMethods),\n            }\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n    //                           Constructor                           //\n    /////////////////////////////////////////////////////////////////////\n\n    /// @notice         Constructor for the contract, setting the config note\n    /// @custom:privacy private\n    /// @param          divinity The divinity address, invoked by the oracle\n    /// @param          private_oracle The private oracle contract address\n    /// @param          token The token used to bet\n    /// @param          bet_amount The bet amount\n    #[aztec(private)]\n    fn constructor(divinity: AztecAddress, private_oracle: AztecAddress, token: AztecAddress, bet_amount: Field) {\n        let mut config_note = ConfigNote::new(divinity, private_oracle, token, bet_amount);\n        storage.config.initialize(&mut config_note, Option::none(), false);\n    }\n\n    /////////////////////////////////////////////////////////////////////\n    //                   Private external functions                    //\n    /////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////////////////////////////////////////\n    //                   Private internal functions                    //\n    /////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////////////////////////////////////////\n    //             Public unconstrained external functions             //\n    /////////////////////////////////////////////////////////////////////\n\n    /// @notice         Gets the config note\n    /// @custom:privacy unconstrained\n    /// @return         The config note (divinity, private oracle, token, bet_amount)\n    unconstrained fn get_config_unconstrained() -> ConfigNote {\n        storage.config.view_note()\n    }\n\n    /// @notice         Gets the bet notes for an user\n    /// @custom:privacy unconstrained\n    /// @param          start_offset The offset to start from\n    /// @return         The bet notes (padded with empty notes, up to 10)\n    unconstrained fn get_user_bets_unconstrained(start_offset: u32) -> [Option<BetNote>; 10] {\n        let user_bets_getter_option = NoteViewerOptions::new().set_offset(start_offset);\n        storage.bets.view_notes(user_bets_getter_option)\n    }\n\n    /// @notice         Compute the note hash and nullifier for a note\n    /// @custom:privacy unconstrained\n    /// @param          contract_address The contract address (this)\n    /// @param          nonce The nonce\n    /// @param          storage_slot The storage slot of the note\n    /// @param          preimage The preimage of the note\n    /// @return         The note hash and nullifier\n    unconstrained fn compute_note_hash_and_nullifier(contract_address: Field, nonce: Field, storage_slot: Field, preimage: [Field; CONFIG_NOTE_LEN]) -> [Field; 4] {\n        let note_header = NoteHeader::new(contract_address, nonce, storage_slot);\n        note_utils::compute_note_hash_and_nullifier(ConfigNoteMethods, note_header, preimage)\n    }\n}",
        "path": "/home/shaito/wonderland/aztec-coin-toss-pvp/src/main.nr"
      },
      "4": {
        "source": "mod poseidon;\nmod mimc;\n\n#[foreign(sha256)]\npub fn sha256<N>(_input: [u8; N]) -> [u8; 32] {}\n\n#[foreign(blake2s)]\npub fn blake2s<N>(_input: [u8; N]) -> [u8; 32] {}\n\nstruct PedersenPoint {\n   x : Field,\n   y : Field,\n}\n\npub fn pedersen_commitment<N>(input: [Field; N]) -> PedersenPoint {\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[foreign(pedersen)]\npub fn __pedersen_commitment_with_separator<N>(_input: [Field; N], _separator: u32) -> [Field; 2] {}\n\npub fn pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> PedersenPoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    PedersenPoint { x: values[0], y: values[1] }\n}\n\npub fn pedersen_hash<N>(input: [Field; N]) -> Field {\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<N>(_input: [Field; N], _separator: u32) -> Field {}\n\npub fn hash_to_field<N>(_input: [Field; N]) -> Field {\n    let mut inputs_as_bytes = [];\n\n    for i in 0..N {\n        let input_bytes = _input[i].to_le_bytes(32);\n        for i in 0..32 {\n            inputs_as_bytes = inputs_as_bytes.push_back(input_bytes[i]);\n        }\n    }\n\n    let hashed_input = blake2s(inputs_as_bytes);\n    crate::field::bytes32_to_field(hashed_input)\n}\n\n#[foreign(keccak256)]\npub fn keccak256<N>(_input: [u8; N], _message_size: u32) -> [u8; 32] {}\n\n",
        "path": "std/hash.nr"
      },
      "33": {
        "source": "struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n",
        "path": "std/option.nr"
      },
      "92": {
        "source": "use dep::protocol_types::constants::{\n    RETURN_VALUES_LENGTH,\n    MAX_READ_REQUESTS_PER_CALL,\n    MAX_PENDING_READ_REQUESTS_PER_CALL,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    GENERATOR_INDEX__FUNCTION_ARGS,\n    BLOCK_HEADER_LENGTH,\n    CONTRACT_DEPLOYMENT_DATA_LENGTH,\n    CALL_CONTEXT_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH,\n    CONTRACT_STORAGE_READ_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    GENERATOR_INDEX__BLOCK_HASH,\n    GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__FUNCTION_DATA,\n    GENERATOR_INDEX__PUBLIC_DATA_READ,\n    GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST,\n    GENERATOR_INDEX__CALL_CONTEXT,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA,\n};\n\nuse crate::oracle::debug_log;\nuse crate::types::vec::BoundedVec;\nuse crate::types::point::Point;\nuse crate::hash::pedersen_hash;\n\n// docs:start:private-global-variables\nstruct PrivateGlobalVariables {\n    chain_id: Field,\n    version: Field,\n}\n// docs:end:private-global-variables\n\nimpl PrivateGlobalVariables {\n    fn serialize(self) -> [Field; 2] {\n        [self.chain_id, self.version]\n    }\n}\n\n// docs:start:public-global-variables\nstruct PublicGlobalVariables {\n    chain_id: Field,\n    version: Field,\n    block_number: Field,\n    timestamp: Field,\n}\n// docs:end:public-global-variables\n\nimpl PublicGlobalVariables {\n    fn serialize(self) -> [Field; 4] {\n        [self.chain_id, self.version, self.block_number, self.timestamp]\n    }\n}\n\n// docs:start:contract-deployment-data\nstruct ContractDeploymentData {\n    deployer_public_key: Point,\n    constructor_vk_hash : Field,\n    function_tree_root : Field,\n    contract_address_salt : Field,\n    portal_contract_address : Field,\n}\n// docs:end:contract-deployment-data\n\nimpl ContractDeploymentData {\n    fn serialize(self) -> [Field; CONTRACT_DEPLOYMENT_DATA_LENGTH] {\n        [\n            self.deployer_public_key.x,\n            self.deployer_public_key.y,\n            self.constructor_vk_hash,\n            self.function_tree_root,\n            self.contract_address_salt,\n            self.portal_contract_address,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA)\n    }\n}\n\n// PrivateContextInputs are expected to be provided to each private function\n// docs:start:private-context-inputs\nstruct PrivateContextInputs {\n    call_context : CallContext,\n    block_header: BlockHeader,\n    contract_deployment_data: ContractDeploymentData,\n    private_global_variables: PrivateGlobalVariables,\n}\n// docs:end:private-context-inputs\n\n// PublicContextInputs are expected to be provided to each public function\n// docs:start:public-context-inputs\nstruct PublicContextInputs {\n    call_context: CallContext,\n    block_header: BlockHeader,\n\n    public_global_variables: PublicGlobalVariables,\n}\n// docs:end:public-context-inputs\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : Field,\n    storage_contract_address : Field,\n    portal_contract_address : Field,\n    function_selector: Field,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n    is_contract_deployment: bool,\n}\n// docs:end:call-context\n\nimpl CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        [\n            self.msg_sender,\n            self.storage_contract_address,\n            self.portal_contract_address,\n            self.function_selector,\n            self.is_delegate_call as Field,\n            self.is_static_call as Field,\n            self.is_contract_deployment as Field,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\n// docs:start:block-header\nstruct BlockHeader {\n    note_hash_tree_root : Field,\n    nullifier_tree_root : Field,\n    contract_tree_root : Field,\n    l1_to_l2_messages_tree_root : Field,\n    archive_root: Field,\n    public_data_tree_root: Field,\n    global_variables_hash: Field,\n}\n// docs:end:block-header\n\nimpl BlockHeader {\n    // NOTE: this order must match the order in `private_circuit_public_inputs.hpp`\n    pub fn serialize(self) -> [Field; BLOCK_HEADER_LENGTH] {\n        [\n            self.note_hash_tree_root,\n            self.nullifier_tree_root,\n            self.contract_tree_root,\n            self.l1_to_l2_messages_tree_root,\n            self.archive_root,\n            self.public_data_tree_root,\n            self.global_variables_hash,\n        ]\n    }\n\n    pub fn deserialize(deserialized: [Field; BLOCK_HEADER_LENGTH]) -> Self {\n        BlockHeader {\n            note_hash_tree_root: deserialized[0],\n            nullifier_tree_root: deserialized[1],\n            contract_tree_root: deserialized[2],\n            l1_to_l2_messages_tree_root: deserialized[3],\n            archive_root: deserialized[4],\n            public_data_tree_root: deserialized[5],\n            global_variables_hash: deserialized[6],\n        }\n    }\n\n    pub fn empty() -> Self {\n        Self { note_hash_tree_root: 0, nullifier_tree_root: 0, contract_tree_root: 0, l1_to_l2_messages_tree_root: 0, archive_root: 0, public_data_tree_root: 0, global_variables_hash: 0 }\n    }\n\n    pub fn block_hash(self) -> Field {\n        // TODO(#3442): Unify the ordering in `BlockHeader::serialize` function and the ordering\n        // in the block hash preimage --> This requires changes in the circuits.\n        let inputs = [\n            self.global_variables_hash,\n            self.note_hash_tree_root,\n            self.nullifier_tree_root,\n            self.contract_tree_root,\n            self.l1_to_l2_messages_tree_root,\n            self.public_data_tree_root\n        ];\n        pedersen_hash(inputs, GENERATOR_INDEX__BLOCK_HASH)\n    }\n}\n\nstruct FunctionData {\n    function_selector: Field,\n    is_internal: bool,\n    is_private: bool,\n    is_constructor: bool,\n}\n\nimpl FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash([\n            self.function_selector,\n            self.is_internal as Field,\n            self.is_private as Field,\n            self.is_constructor as Field,\n        ], GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    read_requests: [Field; crate::abi::MAX_READ_REQUESTS_PER_CALL],\n    pending_read_requests: [Field; crate::abi::MAX_PENDING_READ_REQUESTS_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    nullified_commitments: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    private_call_stack: [Field; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_l2_to_l1_msgs: [Field; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    // Explore introducing a new type like uint256 (similar to Point), so it's more explicit that\n    // we're talking about a single number backed by two field elements.\n    encrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    encrypted_log_preimages_length: Field,\n    unencrypted_log_preimages_length: Field,\n    block_header: BlockHeader,\n    contract_deployment_data: ContractDeploymentData,\n    chain_id: Field,\n    version: Field,\n}\n\nimpl PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0); \n        fields.push(self.call_context.hash());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.pending_read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.nullified_commitments);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_header.serialize());\n        fields.push(self.contract_deployment_data.hash());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n\n        pedersen_hash(fields.storage, GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)\n    }\n\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.pending_read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_header.serialize());\n        fields.push_array(self.contract_deployment_data.serialize());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.storage\n    }\n}\n\nstruct ContractStorageRead {\n    storage_slot: Field,\n    value: Field,\n}\n\nimpl ContractStorageRead {\n    pub fn serialize(self) -> [Field; CONTRACT_STORAGE_READ_LENGTH] {\n        [self.storage_slot, self.value]\n    }\n\n    pub fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_READ)\n    }\n\n    pub fn empty() -> Self {\n        Self { storage_slot: 0, value: 0 }\n    }\n}\n\nstruct ContractStorageUpdateRequest {\n    storage_slot: Field,\n    old_value: Field,\n    new_value: Field,\n}\n\nimpl ContractStorageUpdateRequest {\n    pub fn serialize(self) -> [Field; CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH] {\n        [self.storage_slot, self.old_value, self.new_value]\n    }\n\n    pub fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST)\n    }\n\n    pub fn empty() -> Self {\n        Self { storage_slot: 0, old_value: 0, new_value: 0 }\n    }\n}\n\nstruct PublicCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    contract_storage_update_requests: [ContractStorageUpdateRequest; MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n    contract_storage_read: [ContractStorageRead; MAX_PUBLIC_DATA_READS_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; crate::abi::MAX_NEW_NULLIFIERS_PER_CALL],\n    new_l2_to_l1_msgs: [Field; crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_log_preimages_length: Field,\n    block_header: BlockHeader,\n    prover_address: Field,\n}\n\nimpl PublicCircuitPublicInputs {\n    \n    pub fn hash(self) -> Field {\n        let mut inputs: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0);\n        inputs.push(self.call_context.hash());\n        inputs.push(self.args_hash);\n        inputs.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            inputs.push(self.contract_storage_update_requests[i].hash());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            inputs.push(self.contract_storage_read[i].hash());\n        }\n        inputs.push_array(self.public_call_stack);\n        inputs.push_array(self.new_commitments);\n        inputs.push_array(self.new_nullifiers);\n        inputs.push_array(self.new_l2_to_l1_msgs);\n\n        inputs.push_array(self.unencrypted_logs_hash);\n        inputs.push(self.unencrypted_log_preimages_length);\n        inputs.push_array(self.block_header.serialize());\n        inputs.push(self.prover_address);\n\n        pedersen_hash(inputs.storage, GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS)\n    }\n\n    pub fn serialize(self) -> [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());   \n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            fields.push_array(self.contract_storage_update_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            fields.push_array(self.contract_storage_read[i].serialize());\n        }\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_header.serialize());\n        fields.push(self.prover_address);\n        fields.storage\n    }\n}\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hasher {\n    pub fn new()-> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n\n    pub fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nglobal ARGS_HASH_CHUNK_LENGTH: u32 = 32;\nglobal ARGS_HASH_CHUNK_COUNT: u32 = 16;\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < (args.len() as u32) {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < (args.len() as u32) {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n",
        "path": "/aztec/abi.nr"
      },
      "94": {
        "source": "use dep::protocol_types::constants::{\n    EMPTY_NULLIFIED_COMMITMENT,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_READ_REQUESTS_PER_CALL,\n    MAX_PENDING_READ_REQUESTS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH,\n};\n\nuse crate::abi;\n\nuse crate::abi::{\n    hash_args,\n    CallContext,\n    ContractDeploymentData,\n    BlockHeader,\n    FunctionData,\n    PrivateCircuitPublicInputs,\n    PublicCircuitPublicInputs,\n};\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// l1 to l2 messaging\nuse crate::messaging::process_l1_to_l2_message;\nuse crate::private_call_stack_item::PrivateCallStackItem;\nuse crate::public_call_stack_item::PublicCallStackItem;\n\nuse crate::types::{\n    vec::BoundedVec,\n    point::Point,\n};\n\nuse crate::utils::arr_copy_slice;\n\nuse crate::oracle::{\n    arguments,\n    call_private_function::call_private_function_internal,\n    public_call::call_public_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal,\n    context::get_portal_address,\n    get_block_header::get_block_header,\n};\n\nuse dep::std::option::Option;\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: abi::PrivateContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    read_requests: BoundedVec<Field, MAX_READ_REQUESTS_PER_CALL>,\n    pending_read_requests: BoundedVec<Field, MAX_PENDING_READ_REQUESTS_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n    nullified_commitments: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<Field, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    block_header: BlockHeader,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: abi::PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            read_requests: BoundedVec::new(0),\n            pending_read_requests: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n            nullified_commitments: BoundedVec::new(0),\n\n            block_header: inputs.block_header,\n\n            private_call_stack: BoundedVec::new(0),\n            public_call_stack: BoundedVec::new(0),\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    pub fn selector(self) -> Field {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_block_header(self, block_number: u32) -> BlockHeader {\n        get_block_header(block_number, self)\n    }\n\n    pub fn finish(self) -> abi::PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = abi::PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            read_requests: self.read_requests.storage,\n            pending_read_requests: self.pending_read_requests.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            nullified_commitments: self.nullified_commitments.storage,\n            private_call_stack: self.private_call_stack.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            encrypted_logs_hash: encrypted_logs_hash,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            encrypted_log_preimages_length: encrypted_log_preimages_length,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_header: self.block_header,\n            contract_deployment_data: self.inputs.contract_deployment_data,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version,\n        };\n        priv_circuit_pub_inputs\n    }\n\n    pub fn push_read_request(&mut self, read_request: Field) {\n        self.read_requests.push(read_request);\n    }\n\n    pub fn push_pending_read_request(&mut self, pending_read_request: Field) {\n        self.pending_read_requests.push(pending_read_request);\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    // We never push a zero nullified_commitment as zero is used to indicate the end\n    // of a field array in private kernel. This routine transparently replaces a\n    // zero value into the special placeholder: EMPTY_NULLIFIED_COMMITMENT.\n    pub fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n        let mut non_zero_nullified = nullified_commitment;\n        if (non_zero_nullified == 0) {\n            non_zero_nullified = EMPTY_NULLIFIED_COMMITMENT;\n        }\n        self.nullified_commitments.push(non_zero_nullified);\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, content: Field) \n    // docs:end:context_message_portal\n    {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        msg_key: Field,\n        content: Field,\n        secret: Field\n    ) \n    // docs:end:context_consume_l1_to_l2_message\n    {\n        let nullifier = process_l1_to_l2_message(self.block_header.l1_to_l2_messages_tree_root, self.this_address(), self.this_portal_address(), self.chain_id(), self.version(), msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let fields = call_private_function_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PrivateCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PrivateCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    function_selector: fields[8], // practically same as fields[1]\n                    is_delegate_call : fields[9] as bool,\n                    is_static_call : fields[10] as bool,\n                    is_contract_deployment: fields[11] as bool,\n                },\n                // TODO handle the offsets as a variable incremented during extraction?\n                args_hash: fields[12],\n                return_values: arr_copy_slice(fields, [0; RETURN_VALUES_LENGTH], 13),\n                read_requests: arr_copy_slice(fields, [0; MAX_READ_REQUESTS_PER_CALL], 17),\n                pending_read_requests: arr_copy_slice(fields, [0; MAX_READ_REQUESTS_PER_CALL], 49),\n                new_commitments: arr_copy_slice(fields, [0; MAX_NEW_COMMITMENTS_PER_CALL], 81),\n                new_nullifiers: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 97),\n                nullified_commitments: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 113),\n                private_call_stack: arr_copy_slice(fields, [0; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL], 129),\n                public_call_stack: arr_copy_slice(fields, [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL], 133),\n                new_l2_to_l1_msgs: arr_copy_slice(fields, [0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL], 137),\n                encrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 139),\n                unencrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 141),\n                encrypted_log_preimages_length: fields[143],\n                unencrypted_log_preimages_length: fields[144],\n                block_header: BlockHeader {\n                    // Must match order in `private_circuit_public_inputs.hpp`\n                    note_hash_tree_root : fields[145],\n                    nullifier_tree_root : fields[146],\n                    contract_tree_root : fields[147],\n                    l1_to_l2_messages_tree_root : fields[148],\n                    archive_root : fields[149],\n                    public_data_tree_root: fields[150],\n                    global_variables_hash: fields[151],\n                },\n                contract_deployment_data: ContractDeploymentData {\n                    deployer_public_key: Point::new(fields[152], fields[153]),\n                    constructor_vk_hash : fields[154],\n                    function_tree_root : fields[155],\n                    contract_address_salt : fields[156],\n                    portal_contract_address : fields[157],\n                },\n                chain_id: fields[158],\n                version: fields[159],\n            },\n            is_execution_request: fields[160] as bool,\n        };\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        assert(item.is_execution_request == false);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.private_call_stack.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) {\n        let fields = enqueue_public_function_call_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PublicCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    function_selector: fields[8], // practically same as fields[1]\n                    is_delegate_call : fields[9] as bool,\n                    is_static_call : fields[10] as bool,\n                    is_contract_deployment: fields[11] as bool,\n                },\n                args_hash: fields[12],\n                return_values: [0; RETURN_VALUES_LENGTH],\n                contract_storage_update_requests: [ContractStorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_read: [ContractStorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_commitments: [0; MAX_NEW_COMMITMENTS_PER_CALL],\n                new_nullifiers: [0; MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs:[0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                unencrypted_logs_hash:[0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                block_header: BlockHeader::empty(),\n                prover_address: 0,\n            },\n            is_execution_request: true,\n        };\n\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n        \n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.public_call_stack.push(item.hash());\n    }\n}\n\nuse crate::abi::{\n    ContractStorageRead,\n    ContractStorageUpdateRequest\n};\n\nstruct PublicContext {\n    inputs: abi::PublicContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    contract_storage_update_requests: BoundedVec<ContractStorageUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL>,\n    contract_storage_read: BoundedVec<ContractStorageRead, MAX_PUBLIC_DATA_READS_PER_CALL>,\n    public_call_stack: BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, crate::abi::MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    new_l2_to_l1_msgs: BoundedVec<Field, crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    unencrypted_logs_hash: BoundedVec<Field, NUM_FIELDS_PER_SHA256>,\n    unencrypted_logs_preimages_length: Field,\n\n    block_header: BlockHeader,\n    prover_address: Field,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: abi::PublicContextInputs, args_hash: Field) -> PublicContext {\n        let empty_storage_read = ContractStorageRead::empty();\n        let empty_storage_update = ContractStorageUpdateRequest::empty();\n        PublicContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            contract_storage_update_requests: BoundedVec::new(empty_storage_update),\n            contract_storage_read: BoundedVec::new(empty_storage_read),\n            public_call_stack: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            \n            unencrypted_logs_hash: BoundedVec::new(0),\n            unencrypted_logs_preimages_length: 0,\n\n            block_header: inputs.block_header,\n            prover_address: 0,\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.public_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.public_global_variables.version\n    }\n\n    pub fn selector(self) -> Field {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn block_number(self) -> Field {\n        self.inputs.public_global_variables.block_number\n    }\n\n    pub fn timestamp(self) -> Field {\n        self.inputs.public_global_variables.timestamp\n    }\n\n    pub fn finish(self) -> abi::PublicCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_log_preimages_length = 0;\n\n\n        // Compute the public call stack hashes\n        let pub_circuit_pub_inputs = abi::PublicCircuitPublicInputs {\n            call_context: self.inputs.call_context, // Done\n            args_hash: self.args_hash, // Done\n            contract_storage_update_requests: self.contract_storage_update_requests.storage,\n            contract_storage_read: self.contract_storage_read.storage,\n            return_values: self.return_values.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_header: self.inputs.block_header,\n            prover_address: self.prover_address,\n        };\n        pub_circuit_pub_inputs\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    pub fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n    }\n\n    pub fn message_portal(&mut self, content: Field) {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    pub fn consume_l1_to_l2_message(&mut self, msg_key: Field, content: Field, secret: Field) {\n        let this = (*self).this_address();\n        let nullifier = process_l1_to_l2_message(self.block_header.l1_to_l2_messages_tree_root, this, self.this_portal_address(), self.chain_id(), self.version(), msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n        args: [Field; ARGS_COUNT],\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = abi::hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            args_hash,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            0,\n        )\n    }\n\n}\n\nstruct Context {\n    private: Option<&mut PrivateContext>,\n    public: Option<&mut PublicContext>,\n}\n\nimpl Context {\n    pub fn private(context: &mut PrivateContext) -> Context {\n        Context {\n            private: Option::some(context),\n            public: Option::none()\n        }\n    }\n\n    pub fn public(context: &mut PublicContext) -> Context {\n        Context {\n            public: Option::some(context),\n            private: Option::none()\n        }\n    }\n\n    pub fn none() -> Context {\n        Context {\n            public: Option::none(),\n            private: Option::none()\n        }\n    }\n}\n",
        "path": "/aztec/context.nr"
      },
      "95": {
        "source": "use dep::std::hash::{pedersen_hash_with_separator, sha256};\nuse dep::protocol_types::constants::{\n  GENERATOR_INDEX__SIGNATURE_PAYLOAD,\n  GENERATOR_INDEX__L1_TO_L2_MESSAGE_SECRET,\n};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (sha256_hashed[15 - i] as Field) * v;\n        low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    let hash_in_a_field = low + high * v;\n\n    hash_in_a_field\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    // TODO(#1205) This is probably not the right index to use\n    pedersen_hash([secret], GENERATOR_INDEX__L1_TO_L2_MESSAGE_SECRET)\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    pedersen_hash_with_separator(inputs, hash_index)\n}\n",
        "path": "/aztec/hash.nr"
      },
      "107": {
        "source": "use crate::abi::PublicContextInputs;\nuse crate::context::{\n    PrivateContext,\n    PublicContext,\n};\nuse crate::note::{\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n    utils::compute_inner_note_hash,\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\nuse dep::protocol_types::constants::EMPTY_NULLIFIED_COMMITMENT;\n\npub fn create_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n    note_interface: NoteInterface<Note, N>,\n    broadcast: bool\n) {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    let set_header = note_interface.set_header;\n    set_header(note, header);\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    let serialize = note_interface.serialize;\n    let serialized_note = serialize(*note);\n    assert(notify_created_note(storage_slot, serialized_note, inner_note_hash) == 0);\n\n    context.push_new_note_hash(inner_note_hash);\n\n    if broadcast {\n        let broadcast = note_interface.broadcast;\n        broadcast(context, storage_slot, *note);\n    }\n}\n\npub fn create_note_hash_from_public<Note, N>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note,\n    note_interface: NoteInterface<Note, N>\n) {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    let set_header = note_interface.set_header;\n    set_header(note, header);\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    context.push_new_note_hash(inner_note_hash);\n}\n\npub fn destroy_note<Note, N>(context: &mut PrivateContext, note: Note, note_interface: NoteInterface<Note, N>) {\n    let mut nullifier = 0;\n    let mut nullified_commitment: Field = EMPTY_NULLIFIED_COMMITMENT;\n    let compute_nullifier = note_interface.compute_nullifier;\n    nullifier = compute_nullifier(note);\n\n    // We also need the note commitment corresponding to the \"nullifier\"\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n    // `nullified_commitment` is used to inform the kernel which pending commitment\n    // the nullifier corresponds to so they can be matched and both squashed/deleted.\n    // nonzero nonce implies \"persistable\" nullifier (nullifies a persistent/in-tree\n    // commitment) in which case `nullified_commitment` is not used since the kernel\n    // just siloes and forwards the nullifier to its output.\n    if (header.is_transient) {\n        // TODO(1718): Can we reuse the note commitment computed in `compute_nullifier`?\n        nullified_commitment = compute_inner_note_hash(note_interface, note);\n    }\n    assert(notify_nullified_note(nullifier, nullified_commitment) == 0);\n\n    context.push_new_nullifier(nullifier, nullified_commitment)\n}\n",
        "path": "/aztec/note/lifecycle.nr"
      },
      "108": {
        "source": "use dep::std::option::Option;\nuse dep::protocol_types::constants::{\n    MAX_READ_REQUESTS_PER_CALL,\n    GET_NOTE_ORACLE_RETURN_LENGTH,\n    GET_NOTES_ORACLE_RETURN_LENGTH,\n    MAX_NOTES_PER_PAGE,\n    VIEW_NOTE_ORACLE_RETURN_LENGTH,\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder},\n    note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_or_nullify,\n};\nuse crate::oracle;\nuse crate::types::vec::BoundedVec;\n\nfn check_note_header<Note, N>(context: PrivateContext, storage_slot: Field, note_interface: NoteInterface<Note, N>, note: Note) {\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n    let contract_address = context.this_address();\n    assert(header.contract_address == contract_address);\n    assert(header.storage_slot == storage_slot);\n}\n\nfn check_note_fields<N>(fields: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        assert(fields[select.field_index] == select.value, \"Mismatch return note field.\");\n    }\n}\n\nfn check_notes_order<N>(fields_0: [Field; N], fields_1: [Field; N], sorts: BoundedVec<Option<Sort>, N>) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let eq = fields_0[sort.field_index] == fields_1[sort.field_index];\n        let lt = fields_0[sort.field_index] as u120 < fields_1[sort.field_index] as u120;\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, N>(context: &mut PrivateContext, storage_slot: Field, note_interface: NoteInterface<Note, N>) -> Note {\n    let note = get_note_internal(storage_slot, note_interface);\n\n    check_note_header(*context, storage_slot, note_interface, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, note);\n\n    context.push_read_request(note_hash_for_read_request);\n    note\n}\n\npub fn get_notes<Note, N, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n    let opt_notes = get_notes_internal(storage_slot, note_interface, options);\n    let mut num_notes = 0;\n    let mut prev_fields = [0; N];\n    for i in 0..opt_notes.len() {\n        let opt_note = opt_notes[i];\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            let serialize = note_interface.serialize;\n            let fields = serialize(note);\n            check_note_header(*context, storage_slot, note_interface, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_read_request(note_hash_for_read_request);\n\n            num_notes += 1;\n        };\n    }\n    if options.limit != 0 {\n        assert(num_notes <= options.limit, \"Invalid number of return notes.\");\n    }\n    opt_notes\n}\n\nunconstrained fn get_note_internal<Note, N>(storage_slot: Field, note_interface: NoteInterface<Note, N>) -> Note {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(storage_slot,\n        note_interface,\n        0,\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        placeholder_note,\n        placeholder_fields)[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, FILTER_ARGS>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n    let (num_selects, select_by, select_values, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let opt_notes = oracle::notes::get_notes(storage_slot,\n        note_interface,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        placeholder_opt_notes,\n        placeholder_fields);\n\n    let filter = options.filter;\n    let filter_args = options.filter_args;\n    filter(opt_notes, filter_args)\n}\n\nunconstrained pub fn view_notes<Note, N>(storage_slot: Field, note_interface: NoteInterface<Note, N>, options: NoteViewerOptions<Note, N>) -> [Option<Note>; MAX_NOTES_PER_PAGE] {\n    let (num_selects, select_by, select_values, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(storage_slot,\n        note_interface,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        placeholder_opt_notes,\n        placeholder_fields)\n}\n\nunconstrained fn flatten_options<Note, N>(selects: BoundedVec<Option<Select>, N>, sorts: BoundedVec<Option<Sort>, N>) -> (u8, [u8; N], [Field; N], [u8; N], [u2; N]) {\n    let mut num_selects = 0;\n    let mut select_by = [0; N];\n    let mut select_values = [0; N];\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by[num_selects] = select.unwrap_unchecked().field_index;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by[i] = sort.unwrap_unchecked().field_index;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (num_selects, select_by, select_values, sort_by, sort_order)\n}\n",
        "path": "/aztec/note/note_getter.nr"
      },
      "110": {
        "source": "use crate::hash::pedersen_hash;\nuse dep::protocol_types::constants::{GENERATOR_INDEX__UNIQUE_COMMITMENT, GENERATOR_INDEX__SILOED_COMMITMENT};\n\npub fn compute_inner_hash(storage_slot: Field, note_hash: Field) -> Field {\n    // TODO(#1205) Do we need a generator index here?\n    pedersen_hash([storage_slot, note_hash], 0)\n}\n\npub fn compute_siloed_hash(contract_address: Field, inner_note_hash: Field) -> Field {\n    let inputs = [contract_address, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__SILOED_COMMITMENT)\n}\n\npub fn compute_unique_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_COMMITMENT)\n}\n",
        "path": "/aztec/note/note_hash.nr"
      },
      "114": {
        "source": "use dep::protocol_types::constants::GENERATOR_INDEX__OUTER_NULLIFIER;\nuse crate::{\n    note::{\n        note_hash::{compute_inner_hash, compute_siloed_hash, compute_unique_hash},\n        note_header::NoteHeader,\n        note_interface::NoteInterface,\n    },\n    utils::arr_copy_slice,\n    hash::pedersen_hash,\n};\n\npub fn compute_inner_note_hash<Note, N>(note_interface: NoteInterface<Note, N>, note: Note) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n\n    let compute_note_hash = note_interface.compute_note_hash;\n    let note_hash = compute_note_hash(note);\n\n    compute_inner_hash(header.storage_slot, note_hash)\n}\n\npub fn compute_siloed_note_hash<Note, N>(note_interface: NoteInterface<Note, N>, note_with_header: Note) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let inner_note_hash = compute_inner_note_hash(note_interface, note_with_header);\n\n    compute_siloed_hash(header.contract_address, inner_note_hash)\n}\n\npub fn compute_unique_siloed_note_hash<Note, N>(note_interface: NoteInterface<Note, N>, note_with_header: Note) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let siloed_note_hash = compute_siloed_note_hash(note_interface, note_with_header);\n\n    compute_unique_hash(header.nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, N>(note_interface: NoteInterface<Note, N>, note_with_header: Note) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let compute_nullifier = note_interface.compute_nullifier;\n    let inner_nullifier = compute_nullifier(note_with_header);\n\n    let input = [header.contract_address, inner_nullifier];\n    pedersen_hash(input, GENERATOR_INDEX__OUTER_NULLIFIER)\n}\n\npub fn compute_note_hash_for_read_or_nullify<Note, N>(note_interface: NoteInterface<Note, N>, note_with_header: Note) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386)\n    if (header.is_transient) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        compute_inner_note_hash(note_interface, note_with_header)\n    } else if (header.nonce == 0) {\n        // If not transient and nonce is zero, that means we are reading a public note.\n        compute_siloed_note_hash(note_interface, note_with_header)\n    } else {\n        // When nonce is nonzero, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the unique_siloed_note_hash which has already been hashed with\n        // contract address and then nonce. This hash will match the existing leaf in the private\n        // data tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        compute_unique_siloed_note_hash(note_interface, note_with_header)\n    }\n}\n\npub fn compute_note_hash_and_nullifier<Note, N, S>(note_interface: NoteInterface<Note, N>, note_header: NoteHeader, serialized_note: [Field; S]) -> [Field; 4] {\n    let deserialize = note_interface.deserialize;\n    let set_header = note_interface.set_header;\n    let mut note = deserialize(arr_copy_slice(serialized_note, [0; N], 0));\n    set_header(&mut note, note_header);\n\n    let compute_note_hash = note_interface.compute_note_hash;\n    let note_hash = compute_note_hash(note);\n    let inner_note_hash = compute_inner_hash(note_header.storage_slot, note_hash);\n\n    let siloed_note_hash = compute_siloed_hash(note_header.contract_address, inner_note_hash);\n\n    let unique_siloed_note_hash = compute_unique_hash(note_header.nonce, siloed_note_hash);\n\n    let compute_nullifier = note_interface.compute_nullifier;\n    let inner_nullifier = compute_nullifier(note);\n\n    [inner_note_hash, siloed_note_hash, unique_siloed_note_hash, inner_nullifier]\n}\n",
        "path": "/aztec/note/utils.nr"
      },
      "130": {
        "source": "use dep::std::option::Option;\nuse crate::note::{\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n};\nuse crate::utils::arr_copy_slice;\n\n#[oracle(notifyCreatedNote)]\nfn notify_created_note_oracle<N>(_storage_slot: Field, _serialized_note: [Field; N], _inner_note_hash: Field) -> Field {}\n\nunconstrained pub fn notify_created_note<N>(storage_slot: Field, serialized_note: [Field; N], inner_note_hash: Field) -> Field {\n    notify_created_note_oracle(storage_slot, serialized_note, inner_note_hash)\n}\n\n#[oracle(notifyNullifiedNote)]\nfn notify_nullified_note_oracle<N>(_nullifier: Field, _inner_note_hash: Field) -> Field {}\n\nunconstrained pub fn notify_nullified_note<N>(nullifier: Field, inner_note_hash: Field) -> Field {\n    notify_nullified_note_oracle(nullifier, inner_note_hash)\n}\n\n#[oracle(getNotes)]\nfn get_notes_oracle<N, S>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by: [u8; N],\n    _select_values: [Field; N],\n    _sort_by: [u8; N],\n    _sort_order: [u2; N],\n    _limit: u32,\n    _offset: u32,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<N, S>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; N],\n    select_values: [Field; N],\n    sort_by: [u8; N],\n    sort_order: [u2; N],\n    limit: u32,\n    offset: u32,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        limit,\n        offset,\n        return_size,\n        placeholder_fields)\n}\n\nunconstrained pub fn get_notes<Note, N, M, S, NS>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    num_selects: u8,\n    select_by: [u8; M],\n    select_values: [Field; M],\n    sort_by: [u8; M],\n    sort_order: [u2; M],\n    limit: u32,\n    offset: u32,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS] // TODO: Remove it and use `limit` to initialize the note array.\n) -> [Option<Note>; S] {\n    let fields = get_notes_oracle_wrapper(storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        limit,\n        offset,\n        placeholder_fields);\n    let num_notes = fields[0] as u32;\n    let contract_address = fields[1];\n    let deserialize = note_interface.deserialize;\n    let set_header = note_interface.set_header;\n    for i in 0..placeholder_opt_notes.len() {\n        if i as u32 < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: Field = 2; // num_notes & contract_address.\n            let extra_preimage_length: Field = 2; // nonce & is_transient.\n            let read_offset: Field = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let is_transient = fields[read_offset + 1] as bool;\n            let header = NoteHeader { contract_address, nonce, storage_slot, is_transient };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = deserialize(serialized_note);\n            set_header(&mut note, header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n#[oracle(checkNullifierExists)]\nfn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n",
        "path": "/aztec/oracle/notes.nr"
      },
      "137": {
        "source": "use dep::std::option::Option;\nuse dep::protocol_types::constants::EMPTY_NULLIFIED_COMMITMENT;\nuse crate::context::{PrivateContext, Context};\nuse crate::note::{\n    lifecycle::create_note,\n    note_getter::{get_note, view_notes},\n    note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::singleton::compute_singleton_initialization_nullifier;\n\n// docs:start:struct\nstruct ImmutableSingleton<Note, N> {\n    context: Option<&mut PrivateContext>,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    compute_initialization_nullifier: fn (Field, Option<Field>) -> Field,\n}\n// docs:end:struct\n\nimpl<Note, N> ImmutableSingleton<Note, N> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        note_interface: NoteInterface<Note, N>,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        ImmutableSingleton {\n            context: context.private,\n            storage_slot,\n            note_interface,\n            compute_initialization_nullifier: compute_singleton_initialization_nullifier,\n        }\n    }\n    // docs:end:new\n\n    // docs:start:is_initialized\n    unconstrained pub fn is_initialized(self, owner: Option<Field>) -> bool {\n        let compute_initialization_nullifier = self.compute_initialization_nullifier;\n        let nullifier = compute_initialization_nullifier(self.storage_slot, owner);\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // docs:start:initialize\n    pub fn initialize(\n        self,\n        note: &mut Note, \n        owner: Option<Field>,\n        broadcast: bool,\n    ) {\n        let context = self.context.unwrap();\n\n        // Nullify the storage slot.\n        let compute_initialization_nullifier = self.compute_initialization_nullifier;\n        let nullifier = compute_initialization_nullifier(self.storage_slot, owner);\n        context.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT);\n\n        create_note(\n            context,\n            self.storage_slot,\n            note,\n            self.note_interface,\n            broadcast,\n        );\n    }\n    // docs:end:initialize\n\n    // docs:start:get_note\n    pub fn get_note(self) -> Note {\n        let context = self.context.unwrap();\n        let storage_slot = self.storage_slot;\n        get_note(context, storage_slot, self.note_interface)\n    }\n    // docs:end:get_note\n\n    // docs:start:view_note\n    unconstrained pub fn view_note(self) -> Note {\n        let options = NoteViewerOptions::new().set_limit(1);\n        view_notes(self.storage_slot, self.note_interface, options)[0].unwrap()\n    }\n    // docs:end:view_note\n}\n",
        "path": "/aztec/state_vars/immutable_singleton.nr"
      },
      "140": {
        "source": "use dep::std::option::Option;\nuse crate::abi::PublicContextInputs;\nuse dep::protocol_types::constants::{MAX_NOTES_PER_PAGE, MAX_READ_REQUESTS_PER_CALL};\nuse crate::context::{PrivateContext, PublicContext, Context};\nuse crate::note::{\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note},\n    note_getter::{get_notes, view_notes},\n    note_getter_options::NoteGetterOptions,\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_or_nullify,\n};\n\n// docs:start:struct\nstruct Set<Note, N> {\n    context: Context,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n}\n// docs:end:struct\n\nimpl<Note, N> Set<Note, N> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        note_interface: NoteInterface<Note, N>,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Set {\n            context,\n            storage_slot,\n            note_interface,\n        }\n    }\n    // docs:end:new\n\n    // docs:start:insert\n    pub fn insert(self,\n        note: &mut Note,\n        broadcast: bool,\n    ) {\n        create_note(\n            self.context.private.unwrap(),\n            self.storage_slot,\n            note,\n            self.note_interface,\n            broadcast,\n        );\n    }\n    // docs:end:insert\n\n    // docs:start:insert_from_public\n    pub fn insert_from_public(self, note: &mut Note) {\n        create_note_hash_from_public(\n            self.context.public.unwrap(),\n            self.storage_slot,\n            note,\n            self.note_interface,\n        );\n    }\n    // docs:end:insert_from_public\n    \n    // DEPRECATED\n    fn assert_contains_and_remove(_self: Self, _note: &mut Note, _nonce: Field) {\n        assert(false, \"`assert_contains_and_remove` has been deprecated. Please call PXE.addNote() to add a note to the database. Then use Set.get_notes() and Set.remove() in your contract to verify and remove a note.\");\n    }\n\n    // DEPRECATED\n    fn assert_contains_and_remove_publicly_created(_self: Self, _note: &mut Note) {\n        assert(false, \"`assert_contains_and_remove_publicly_created` has been deprecated. Please call PXE.addNote() to add a note to the database. Then use Set.get_notes() and Set.remove() in your contract to verify and remove a note.\");\n    }\n\n    // docs:start:remove\n    pub fn remove(self, note: Note) {\n        let context = self.context.private.unwrap();\n        let note_hash = compute_note_hash_for_read_or_nullify(self.note_interface, note);\n        let has_been_read = context.read_requests.any(|r| r == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note(\n            context,\n            note,\n            self.note_interface,\n        );\n    }\n    // docs:end:remove\n\n    // docs:start:get_notes\n    pub fn get_notes<FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, FILTER_ARGS>,\n    ) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n        let storage_slot = self.storage_slot;\n        let opt_notes = get_notes(\n            self.context.private.unwrap(),\n            storage_slot,\n            self.note_interface,\n            options,\n        );\n        opt_notes\n    }\n    // docs:end:get_notes\n\n    // docs:start:view_notes\n    unconstrained pub fn view_notes(\n        self,\n        options: NoteViewerOptions<Note, N>,\n    ) -> [Option<Note>; MAX_NOTES_PER_PAGE] {\n        view_notes(self.storage_slot, self.note_interface, options)\n    }\n    // docs:end:view_notes\n}\n",
        "path": "/aztec/state_vars/set.nr"
      },
      "141": {
        "source": "use dep::std::option::Option;\nuse dep::protocol_types::constants::{EMPTY_NULLIFIED_COMMITMENT, GENERATOR_INDEX__INITIALIZATION_NULLIFIER};\nuse crate::context::{PrivateContext, PublicContext, Context};\nuse crate::note::{\n    lifecycle::{create_note, destroy_note},\n    note_getter::{get_note, view_notes},\n    note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::oracle::{\n    get_secret_key::get_secret_key,\n    notes::check_nullifier_exists,\n};\nuse crate::hash::pedersen_hash;\n\npub fn compute_singleton_initialization_nullifier(storage_slot: Field, owner: Option<Field>) -> Field {\n    if owner.is_some() {\n        let secret = get_secret_key(owner.unwrap_unchecked());\n        pedersen_hash([storage_slot, secret.low, secret.high],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER)\n    } else {\n        pedersen_hash([storage_slot], GENERATOR_INDEX__INITIALIZATION_NULLIFIER)\n    }\n}\n\n// docs:start:struct\nstruct Singleton<Note, N> {\n    context: Option<&mut PrivateContext>,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    compute_initialization_nullifier: fn (Field, Option<Field>) -> Field,\n}\n// docs:end:struct\n\nimpl<Note, N> Singleton<Note, N> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        note_interface: NoteInterface<Note, N>,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Singleton {\n            context: context.private,\n            storage_slot,\n            note_interface,\n            compute_initialization_nullifier: compute_singleton_initialization_nullifier,\n        }\n    }\n    // docs:end:new\n\n    // docs:start:is_initialized\n    unconstrained pub fn is_initialized(self, owner: Option<Field>) -> bool {\n        let compute_initialization_nullifier = self.compute_initialization_nullifier;\n        let nullifier = compute_initialization_nullifier(self.storage_slot, owner);\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // docs:start:initialize\n    pub fn initialize(\n        self,\n        note: &mut Note,\n        owner: Option<Field>,\n        broadcast: bool,\n    ) {\n        let context = self.context.unwrap();\n\n        // Nullify the storage slot.\n        let compute_initialization_nullifier = self.compute_initialization_nullifier;\n        let nullifier = compute_initialization_nullifier(self.storage_slot, owner);\n        context.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT);\n\n        create_note(context, self.storage_slot, note, self.note_interface, broadcast);\n    }\n    // docs:end:initialize\n\n    // docs:start:replace\n    pub fn replace(\n        self,\n        new_note: &mut Note,\n        broadcast: bool,\n    ) {\n        let context = self.context.unwrap();\n        let prev_note = get_note(context, self.storage_slot, self.note_interface);\n\n        // Nullify previous note.\n        destroy_note(context, prev_note, self.note_interface);\n\n        // Add replacement note.\n        create_note(context, self.storage_slot, new_note, self.note_interface, broadcast);\n    }\n    // docs:end:replace\n\n    // docs:start:get_note\n    pub fn get_note(self, broadcast: bool) -> Note {\n        let context = self.context.unwrap();\n        let mut note = get_note(context, self.storage_slot, self.note_interface);\n\n        // Nullify current note to make sure it's reading the latest note.\n        destroy_note(context, note, self.note_interface);\n\n        // Add the same note again.\n        // Because a nonce is added to every note in the kernel, its nullifier will be different.\n        create_note(context, self.storage_slot, &mut note, self.note_interface, broadcast);\n\n        note\n    }\n    // docs:end:get_note\n\n    // docs:start:view_note\n    unconstrained pub fn view_note(self) -> Note {\n        let options = NoteViewerOptions::new().set_limit(1);\n        view_notes(self.storage_slot, self.note_interface, options)[0].unwrap()\n    }\n    // docs:end:view_note\n}\n",
        "path": "/aztec/state_vars/singleton.nr"
      },
      "145": {
        "source": "struct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    len: Field,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    pub fn new(initial_value: T) -> Self {\n        BoundedVec { storage: [initial_value; MaxLen], len: 0 }\n    }\n\n    pub fn get(mut self: Self, index: Field) -> T {\n        assert(index as u64 < self.len as u64);\n        self.storage[index]\n    }\n\n    pub fn get_unchecked(mut self: Self, index: Field) -> T {\n        self.storage[index]\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len as u64 < MaxLen as u64);\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn push_array<Len>(&mut self, array: [T; Len]) {\n        let newLen = self.len + array.len();\n        assert(newLen as u64 <= MaxLen as u64);\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = newLen;\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n\n        let elem = self.storage[self.len - 1];\n        self.len -= 1;\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if (!exceeded_len) {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n}\n\n#[test]\nfn test_vec_push_pop() {\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(0);\n    assert(vec.len == 0);\n    vec.push(2);\n    assert(vec.len == 1);\n    vec.push(4);\n    assert(vec.len == 2);\n    vec.push(6);\n    assert(vec.len == 3);\n    let x = vec.pop();\n    assert(x == 6);\n    assert(vec.len == 2);\n    assert(vec.get(0) == 2);\n    assert(vec.get(1) == 4);\n}\n\n#[test]\nfn test_vec_push_array() {\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(0);\n    vec.push_array([2, 4]);\n    assert(vec.len == 2);\n    assert(vec.get(0) == 2);\n    assert(vec.get(1) == 4);\n}\n\n#[test(should_fail)]\nfn test_vec_get_out_of_bound() {\n    let mut vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n    vec.push_array([2, 4]);\n    let _x = vec.get(2);\n}\n\n#[test(should_fail)]\nfn test_vec_get_not_declared() {\n    let mut vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n    vec.push_array([2]);\n    let _x = vec.get(1);\n}\n\n#[test(should_fail)]\nfn test_vec_get_uninitialized() {\n    let mut vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n    let _x = vec.get(0);\n}\n\n#[test(should_fail)]\nfn test_vec_push_overflow() {\n    let mut vec: BoundedVec<Field, 1> = BoundedVec::new(0);\n    vec.push(1);\n    vec.push(2);\n}\n\n#[test]\nfn test_vec_any() {\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(0);\n    vec.push_array([2, 4, 6]);\n    assert(vec.any(|v| v == 2) == true);\n    assert(vec.any(|v| v == 4) == true);\n    assert(vec.any(|v| v == 6) == true);\n    assert(vec.any(|v| v == 3) == false);\n}\n\n#[test]\nfn test_vec_any_not_default() {\n    let default_value = 1;\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(default_value);\n    vec.push_array([2, 4]);\n    assert(vec.any(|v| v == default_value) == false);\n}\n",
        "path": "/aztec/types/vec.nr"
      },
      "151": {
        "source": "pub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: Field) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n\npub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() as u32 < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// TODO(#3470): Copied over from https://github.com/AztecProtocol/aztec-packages/blob/a07c4bd47313be6aa604a63f37857eb0136b41ba/yarn-project/noir-protocol-circuits/src/crates/rollup-lib/src/base/base_rollup_inputs.nr#L599\n// move to a shared place?\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    dep::std::eddsa::lt_bytes32(lhs, rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    dep::std::eddsa::lt_bytes32(rhs, lhs)\n}",
        "path": "/aztec/utils.nr"
      },
      "153": {
        "source": "/////////////////////////////////////////////////////////////////////\n//                             Imports                             //\n/////////////////////////////////////////////////////////////////////\n\nuse dep::aztec::{\n    context::PrivateContext,\n    log::emit_encrypted_log,\n    note::{\n        note_header::NoteHeader,\n        note_interface::NoteInterface,\n        utils::compute_note_hash_for_read_or_nullify,\n    },\n    oracle::{\n        get_public_key::get_public_key,\n        get_secret_key::get_secret_key,\n        notes::check_nullifier_exists,\n        notes::check_nullifier_exists_oracle,\n        rand::rand,\n    },\n    types::address::AztecAddress\n};\n\nuse dep::protocol_types::{\n    constants::EMPTY_NULLIFIED_COMMITMENT,\n};\n\nuse dep::std::option::Option;\n\n\n/////////////////////////////////////////////////////////////////////\n//                              Class                              //\n/////////////////////////////////////////////////////////////////////\n\n/// @notice A note that represents a given bet, of a given user\n/// @member owner The owner of the note\n/// @member bet_id The id of the bet (the escrow randomness is reused for this)\n/// @member bet The bet outcome given by the user (true or false)\n/// @member header The note header\nstruct BetNote {\n    owner: AztecAddress,\n    bet_id: Field,\n    bet: bool, // Heads is 0 (False). Tails is 1 (True).\n    escrow_randomness: Field,\n    header: NoteHeader\n}\n\nglobal BET_NOTE_LEN: Field = 4;\n\nimpl BetNote {\n    /////////////////////////////////////////////////////////////////////\n    //                         Public methods                          //\n    /////////////////////////////////////////////////////////////////////\n\n    /// @notice Bet note constructor\n    /// @param _context The currenct context, used to push the bet_id nullifier in order to ensure uniqueness\n    /// @param _owner The owner of the note\n    /// @param _bet_id The id of the bet (randomly generated, by reusing the escrow randomness)\n    /// @param _bet The bet outcome given by the user (true or false, representing head or tail)\n    pub fn new(_context: &mut PrivateContext, _owner: AztecAddress, _bet: bool, _bet_id: Field, _escrow_randomness: Field) -> Self {\n        // Nullify bet id\n        let compute_initialization_nullifier = BetNote::generate_bet_id_nullifier;\n        let nullifier = compute_initialization_nullifier(_bet_id);\n        _context.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT);\n\n        BetNote {\n            owner: _owner,\n            bet_id: _bet_id,\n            bet: _bet,\n            escrow_randomness: _escrow_randomness,\n            header: NoteHeader::empty(),\n        }\n    }\n\n    /// @notice Bet note bet_id nullifying generator\n    /// @param _bet_id The id of the bet to nullify\n    pub fn generate_bet_id_nullifier(_bet_id: Field) -> Field {\n        dep::std::hash::pedersen_hash([_bet_id])\n    }\n\n    /// @notice Bet note bet_id initialization checker. Checks whether the bet_id was added to the nullifying tree\n    /// @param _bet_id The id of the bet to check for nullification status\n    unconstrained pub fn is_id_nullified(_bet_id: Field) -> bool {\n        let compute_initialization_nullifier = BetNote::generate_bet_id_nullifier;\n        let nullifier = compute_initialization_nullifier(_bet_id);\n        check_nullifier_exists(nullifier)\n    }\n\n    /////////////////////////////////////////////////////////////////////\n    //                        Internal methods                         //\n    /////////////////////////////////////////////////////////////////////\n\n    /// @notice Serializes the note\n    fn serialize(self) -> [Field; BET_NOTE_LEN] {\n        [self.owner.address, self.bet_id, self.bet as Field, self.escrow_randomness]\n    }\n\n    /// @notice Deserializes the note\n    fn deserialize(preimage: [Field; BET_NOTE_LEN]) -> Self {\n        BetNote {\n            owner: AztecAddress::new(preimage[0]),\n            bet_id: preimage[1],\n            bet: preimage[2] as bool,\n            escrow_randomness: preimage[3],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    /// @notice Computes the note hash of the note\n    fn compute_note_hash(self) -> Field {\n        dep::std::hash::pedersen_hash([\n            self.owner.address,\n            self.bet_id,\n            self.bet as Field,\n            self.escrow_randomness\n        ])\n    }\n\n    /// @notice Computes the nullifier of the note\n    /// @dev    This is a pretty standard nullifier computation, using the bet_id as the key\n    fn compute_nullifier(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_read_or_nullify(BetNoteMethods, self);\n        let nullifier_key = self.bet_id;\n\n        dep::std::hash::pedersen_hash([\n            note_hash_for_nullify,\n            nullifier_key,\n        ])\n    }\n\n    /// @notice Sets the note header\n    fn set_header(&mut self, header: NoteHeader) {\n        self.header = header;\n    }\n\n    /// @notice Emit the note creation event using the owner public key\n    fn broadcast(self, context: &mut PrivateContext, slot: Field) {\n        let encryption_pub_key = get_public_key(self.owner.address);\n        emit_encrypted_log(\n            context,\n            (*context).this_address(),\n            slot,\n            encryption_pub_key,\n            self.serialize(),\n        );\n    }\n}\n\n/////////////////////////////////////////////////////////////////////\n//                         Global methods                          //\n/////////////////////////////////////////////////////////////////////\n\nfn deserialize(preimage: [Field; BET_NOTE_LEN]) -> BetNote {\n    BetNote::deserialize(preimage)\n}\n\nfn serialize(note: BetNote) -> [Field; BET_NOTE_LEN] {\n    note.serialize()\n}\n\nfn compute_note_hash(note: BetNote) -> Field {\n    note.compute_note_hash()\n}\n\nfn compute_nullifier(note: BetNote) -> Field {\n    note.compute_nullifier()\n}\n\nfn get_header(note: BetNote) -> NoteHeader {\n    note.header\n}\n\nfn set_header(note: &mut BetNote, header: NoteHeader) {\n    note.set_header(header)\n}\n\nfn broadcast(context: &mut PrivateContext, slot: Field, note: BetNote) {\n    note.broadcast(context, slot);\n}\n\nglobal BetNoteMethods = NoteInterface {\n    deserialize,\n    serialize,\n    compute_note_hash,\n    compute_nullifier,\n    get_header,\n    set_header,\n    broadcast,\n};",
        "path": "/home/shaito/wonderland/aztec-coin-toss-pvp/src/types/bet_note.nr"
      },
      "154": {
        "source": "/////////////////////////////////////////////////////////////////////\n//                             Imports                             //\n/////////////////////////////////////////////////////////////////////\n\nuse dep::aztec::{\n    context::PrivateContext,\n    note::{\n        note_header::NoteHeader,\n        note_interface::NoteInterface,\n    },\n    types::address::AztecAddress\n};\n\n/////////////////////////////////////////////////////////////////////\n//                              Class                              //\n/////////////////////////////////////////////////////////////////////\n\n/// @notice a note containing the (immutable) game configuration\n/// @member divinity the address of the divinity used by the oracle\n/// @member private_oracle the address of the private oracle contract\n/// @member token the address of the token used for betting\n/// @member bet_amount the amount of tokens to bet\n/// @member header the note header\nstruct ConfigNote {\n    divinity: AztecAddress,\n    private_oracle: AztecAddress,\n    token: AztecAddress,\n    bet_amount: Field,\n    header: NoteHeader\n}\n\nglobal CONFIG_NOTE_LEN: Field = 4;\n\nimpl ConfigNote {\n    \n    /////////////////////////////////////////////////////////////////////\n    //                         Public methods                          //\n    /////////////////////////////////////////////////////////////////////\n\n    /// @notice create a new config note\n    /// @param _divinity the address of the divinity used by the oracle\n    /// @param _private_oracle the address of the private oracle contract\n    /// @param _token the address of the token used for betting\n    /// @param _amount the amount of tokens to bet\n    pub fn new(_divinity: AztecAddress, _private_oracle: AztecAddress, _token: AztecAddress, _amount: Field) -> Self {\n        ConfigNote {\n            divinity: _divinity,\n            private_oracle: _private_oracle,\n            token: _token,\n            bet_amount: _amount,\n            header: NoteHeader::empty(),\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n    //                        Internal methods                         //\n    /////////////////////////////////////////////////////////////////////\n\n    /// @notice serialize the note\n    fn serialize(self) -> [Field; CONFIG_NOTE_LEN] {\n        [self.divinity.address, self.private_oracle.address, self.token.address, self.bet_amount]\n    }\n\n    /// @notice deserialize the note\n    fn deserialize(preimage: [Field; CONFIG_NOTE_LEN]) -> Self {\n        ConfigNote {\n            divinity: AztecAddress::new(preimage[0]),\n            private_oracle: AztecAddress::new(preimage[1]),\n            token: AztecAddress::new(preimage[2]),\n            bet_amount: preimage[3],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    /// @notice compute the note hash\n    fn compute_note_hash(self) -> Field {\n        dep::std::hash::pedersen_hash([\n            self.divinity.address,\n            self.private_oracle.address,\n            self.token.address,\n            self.bet_amount\n        ])\n    }\n\n    /// @notice this note isn't nullifiable, returns 0\n    fn compute_nullifier(self) -> Field {\n         let _ = self; // Avoid compiler warning (same # acir opcodes and backend size)\n         0\n    }\n\n    /// @notice get the note header\n    fn set_header(&mut self, header: NoteHeader) {\n        self.header = header;\n    }\n\n    /// @notice this notes isn't private, no owner to emit to\n    fn broadcast(self, context: &mut PrivateContext, slot: Field) {\n        // no owner == no broadcast\n        let _ = self; // Avoid compiler warning (same # acir opcodes and backend size)\n        let __ = context;\n        let ___ = slot;\n    }\n}\n\n/////////////////////////////////////////////////////////////////////\n//                         Global methods                          //\n/////////////////////////////////////////////////////////////////////\n\nfn deserialize(preimage: [Field; CONFIG_NOTE_LEN]) -> ConfigNote {\n    ConfigNote::deserialize(preimage)\n}\n\nfn serialize(note: ConfigNote) -> [Field; CONFIG_NOTE_LEN] {\n    note.serialize()\n}\n\nfn compute_note_hash(note: ConfigNote) -> Field {\n    note.compute_note_hash()\n}\n\nfn compute_nullifier(note: ConfigNote) -> Field {\n    note.compute_nullifier()\n}\n\nfn get_header(note: ConfigNote) -> NoteHeader {\n    note.header\n}\n\nfn set_header(note: &mut ConfigNote, header: NoteHeader) {\n    note.set_header(header)\n}\n\nfn broadcast(context: &mut PrivateContext, slot: Field, note: ConfigNote) {\n    note.broadcast(context, slot);\n}\n\nglobal ConfigNoteMethods = NoteInterface {\n    deserialize,\n    serialize,\n    compute_note_hash,\n    compute_nullifier,\n    get_header,\n    set_header,\n    broadcast,\n};",
        "path": "/home/shaito/wonderland/aztec-coin-toss-pvp/src/types/config_note.nr"
      }
    }
  }
}