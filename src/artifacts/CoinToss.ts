
/* Autogenerated file, do not edit! */

/* eslint-disable */
import {
  AztecAddress,
  AztecAddressLike,
  CompleteAddress,
  Contract,
  ContractArtifact,
  ContractBase,
  ContractFunctionInteraction,
  ContractMethod,
  DeployMethod,
  EthAddress,
  EthAddressLike,
  FieldLike,
  Fr,
  Point,
  PublicKey,
  Wallet,
} from '@aztec/aztec.js';
import CoinTossContractArtifactJson from './CoinToss.json' assert { type: 'json' };
export const CoinTossContractArtifact = CoinTossContractArtifactJson as ContractArtifact;

/**
 * Type-safe interface for contract CoinToss;
 */
export class CoinTossContract extends ContractBase {
  
  private constructor(
    completeAddress: CompleteAddress,
    wallet: Wallet,
    portalContract = EthAddress.ZERO
  ) {
    super(completeAddress, CoinTossContractArtifact, wallet, portalContract);
  }
  

  
  /**
   * Creates a contract instance.
   * @param address - The deployed contract's address.
   * @param wallet - The wallet to use when interacting with the contract.
   * @returns A promise that resolves to a new Contract instance.
   */
  public static async at(
    address: AztecAddress,
    wallet: Wallet,
  ) {
    return Contract.at(address, CoinTossContract.artifact, wallet) as Promise<CoinTossContract>;
  }

  
  /**
   * Creates a tx to deploy a new instance of this contract.
   */
  public static deploy(wallet: Wallet, divinity: AztecAddressLike, divinity_bjj_public_key: { point: { x: FieldLike, y: FieldLike } }, private_oracle: AztecAddressLike, token: AztecAddressLike, bet_amount: FieldLike, phase_length: FieldLike) {
    return new DeployMethod<CoinTossContract>(Point.ZERO, wallet, CoinTossContractArtifact, Array.from(arguments).slice(1));
  }

  /**
   * Creates a tx to deploy a new instance of this contract using the specified public key to derive the address.
   */
  public static deployWithPublicKey(publicKey: PublicKey, wallet: Wallet, divinity: AztecAddressLike, divinity_bjj_public_key: { point: { x: FieldLike, y: FieldLike } }, private_oracle: AztecAddressLike, token: AztecAddressLike, bet_amount: FieldLike, phase_length: FieldLike) {
    return new DeployMethod<CoinTossContract>(publicKey, wallet, CoinTossContractArtifact, Array.from(arguments).slice(2));
  }
  

  
  /**
   * Returns this contract's artifact.
   */
  public static get artifact(): ContractArtifact {
    return CoinTossContractArtifact;
  }
  

  /** Type-safe wrappers for the public methods exposed by the contract. */
  public methods!: {
    
    /** _end_bet_phase(round_id: field) */
    _end_bet_phase: ((round_id: FieldLike) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** _increase_bettors(round_id: field) */
    _increase_bettors: ((round_id: FieldLike) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** _init_bjj(serialized: array) */
    _init_bjj: ((serialized: FieldLike[]) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** _initialize(phase_length: field, bet_amount: field, oracle_address: struct, divinity_address: struct, token_address: struct) */
    _initialize: ((phase_length: FieldLike, bet_amount: FieldLike, oracle_address: AztecAddressLike, divinity_address: AztecAddressLike, token_address: AztecAddressLike) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** _set_result(caller: field, round_id: field, answer: array, divinity_cum_sum: array, divinity_plain_embedded: array, divinity_public_key: array) */
    _set_result: ((caller: FieldLike, round_id: FieldLike, answer: FieldLike[], divinity_cum_sum: FieldLike[], divinity_plain_embedded: FieldLike[], divinity_public_key: FieldLike[]) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** _update_cumsum(round_id: field, encrypted_bet_C1_field: array, encrypted_bet_C2_field: array) */
    _update_cumsum: ((round_id: FieldLike, encrypted_bet_C1_field: FieldLike[], encrypted_bet_C2_field: FieldLike[]) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** _validate_claim(round_id: field, amount: field, user_bet: field) */
    _validate_claim: ((round_id: FieldLike, amount: FieldLike, user_bet: FieldLike) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** _validate_encrypted_tail_sum(encrypted_tail_sum_test: array) */
    _validate_encrypted_tail_sum: ((encrypted_tail_sum_test: FieldLike[]) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** bet(bet: boolean, round_id: field, bet_randomness: field, unshield_nonce: field) */
    bet: ((bet: boolean, round_id: FieldLike, bet_randomness: FieldLike, unshield_nonce: FieldLike) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** claim(round_id: field, amount: field, user_randomness: field) */
    claim: ((round_id: FieldLike, amount: FieldLike, user_randomness: FieldLike) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** compute_note_hash_and_nullifier(contract_address: field, nonce: field, storage_slot: field, preimage: array) */
    compute_note_hash_and_nullifier: ((contract_address: FieldLike, nonce: FieldLike, storage_slot: FieldLike, preimage: FieldLike[]) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** get_bet_amount_unconstrained() */
    get_bet_amount_unconstrained: (() => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** get_config_unconstrained() */
    get_config_unconstrained: (() => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** get_divinity_address_unconstrained() */
    get_divinity_address_unconstrained: (() => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** get_oracle_address_unconstrained() */
    get_oracle_address_unconstrained: (() => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** get_phase_length_unconstrained() */
    get_phase_length_unconstrained: (() => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** get_result(round_id: field) */
    get_result: ((round_id: FieldLike) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** get_round_data(round_id: field) */
    get_round_data: ((round_id: FieldLike) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** get_round_id() */
    get_round_id: (() => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** get_token_address_unconstrained() */
    get_token_address_unconstrained: (() => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** get_user_bets_unconstrained(start_offset: integer) */
    get_user_bets_unconstrained: ((start_offset: (bigint | number)) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** is_round_randomness_nullified(round_id: field, randomness: field) */
    is_round_randomness_nullified: ((round_id: FieldLike, randomness: FieldLike) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** oracle_callback(answer: array, data: array, divinity_address: struct) */
    oracle_callback: ((answer: FieldLike[], data: FieldLike[], divinity_address: AztecAddressLike) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** roll(round_id: field, oracle_nonce: field, encrypted_tail_sum: struct) */
    roll: ((round_id: FieldLike, oracle_nonce: FieldLike, encrypted_tail_sum: { C1: { point: { x: FieldLike, y: FieldLike } }, C2: { point: { x: FieldLike, y: FieldLike } } }) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** start_next_round() */
    start_next_round: (() => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;
  };
}
